ID,Smell,Code,FPath
as_1_9,Inefficient Rendering,"class ReactifiedComponent extends React.Component<Props & ReactifyProps> {   container?: HTMLDivElement;    constructor(props: Props & ReactifyProps) {     super(props);     this.setContainerRef = this.setContainerRef.bind(this);   }    componentDidMount() {     this.execute();   }    componentDidUpdate() {     this.execute();   }    componentWillUnmount() {     this.container = undefined;     if (callbacks?.componentWillUnmount) {       callbacks.componentWillUnmount.bind(this)();     }   }    setContainerRef(ref: HTMLDivElement) {     this.container = ref;   }    execute() {     if (this.container) {       renderFn(this.container, this.props);     }   }    render() {     const { id, className } = this.props;      return <div ref={this.setContainerRef} id={id} className={className} />;   } }",C:\Users\Owner\Desktop\DatasetFiles\as_1_9.js
as_2_17,Inefficient Rendering,"class AnotherTestComponent extends React.PureComponent<{}, {}> {   render() {     return <TheChartWithWillUnmountHook id=""another_test"" />;   } }",C:\Users\Owner\Desktop\DatasetFiles\as_2_17.js
as_3_18,Inefficient Rendering,"class AnotherTestComponent extends React.PureComponent<{}, {}> {   render() {     return <TheChartWithWillUnmountHook id=""another_test"" />;   } }",C:\Users\Owner\Desktop\DatasetFiles\as_3_18.js
as_4_60,Inefficient Rendering,"class HorizonRow extends React.PureComponent {   componentDidMount() {     this.drawChart();   }    componentDidUpdate() {     this.drawChart();   }    componentWillUnmount() {     this.canvas = null;   }    drawChart() {     if (this.canvas) {       const {         data: rawData,         yDomain,         width,         height,         bands,         colors,         colorScale,         offsetX,         mode,       } = this.props;        const data =         colorScale === 'change'           ? rawData.map(d => ({ ...d, y: d.y - rawData[0].y }))           : rawData;        const context = this.canvas.getContext('2d');       context.imageSmoothingEnabled = false;       context.clearRect(0, 0, width, height);       // Reset transform       context.setTransform(1, 0, 0, 1, 0, 0);       context.translate(0.5, 0.5);        const step = width / data.length;       // the data frame currently being shown:       const startIndex = Math.floor(Math.max(0, -(offsetX / step)));       const endIndex = Math.floor(         Math.min(data.length, startIndex + width / step),       );        // skip drawing if there's no data to be drawn       if (startIndex > data.length) {         return;       }        // Create y-scale       const [min, max] = yDomain || d3Extent(data, d => d.y);       const y = scaleLinear()         .domain([0, Math.max(-min, max)])         .range([0, height]);        // we are drawing positive & negative bands separately to avoid mutating canvas state       // http://www.html5rocks.com/en/tutorials/canvas/performance/       let hasNegative = false;       // draw positive bands       let value;       let bExtents;       for (let b = 0; b < bands; b += 1) {         context.fillStyle = colors[bands + b];          // Adjust the range based on the current band index.         bExtents = (b + 1 - bands) * height;         y.range([bands * height + bExtents, bExtents]);          // only the current data frame is being drawn i.e. what's visible:         for (let i = startIndex; i < endIndex; i += 1) {           value = data[i].y;           if (value <= 0) {             hasNegative = true;             continue;           }           if (value !== undefined) {             context.fillRect(               offsetX + i * step,               y(value),               step + 1,               y(0) - y(value),             );           }         }       }        // draw negative bands       if (hasNegative) {         // mirror the negative bands, by flipping the canvas         if (mode === 'offset') {           context.translate(0, height);           context.scale(1, -1);         }          for (let b = 0; b < bands; b += 1) {           context.fillStyle = colors[bands - b - 1];            // Adjust the range based on the current band index.           bExtents = (b + 1 - bands) * height;           y.range([bands * height + bExtents, bExtents]);            // only the current data frame is being drawn i.e. what's visible:           for (let ii = startIndex; ii < endIndex; ii += 1) {             value = data[ii].y;             if (value >= 0) {               continue;             }             context.fillRect(               offsetX + ii * step,               y(-value),               step + 1,               y(0) - y(-value),             );           }         }       }     }   }    render() {     const { className, title, width, height } = this.props;      return (       <div className={`horizon-row ${className}`}>         <span className=""title"">{title}</span>         <canvas           ref={c => {             this.canvas = c;           }}           width={width}           height={height}         />       </div>     );   } }  HorizonRow.propTypes = propTypes; HorizonRow.defaultProps = defaultProps;  export default HorizonRow;",C:\Users\Owner\Desktop\DatasetFiles\as_4_60.js
as_5_66,Inefficient Rendering,"class TTestTable extends React.Component {   constructor(props) {     super(props);     this.state = {       control: 0,       liftValues: [],       pValues: [],     };   }    componentDidMount() {     const { control } = this.state;     this.computeTTest(control); // initially populate table   }    getLiftStatus(row) {     const { control, liftValues } = this.state;     // Get a css class name for coloring     if (row === control) {       return 'control';     }     const liftVal = liftValues[row];     if (Number.isNaN(liftVal) || !Number.isFinite(liftVal)) {       return 'invalid'; // infinite or NaN values     }      return liftVal >= 0 ? 'true' : 'false'; // green on true, red on false   }    getPValueStatus(row) {     const { control, pValues } = this.state;     if (row === control) {       return 'control';     }     const pVal = pValues[row];     if (Number.isNaN(pVal) || !Number.isFinite(pVal)) {       return 'invalid';     }      return ''; // p-values won't normally be colored   }    getSignificance(row) {     const { control, pValues } = this.state;     const { alpha } = this.props;     // Color significant as green, else red     if (row === control) {       return 'control';     }      // p-values significant below set threshold     return pValues[row] <= alpha;   }    computeLift(values, control) {     const { liftValPrec } = this.props;     // Compute the lift value between two time series     let sumValues = 0;     let sumControl = 0;     values.forEach((value, i) => {       sumValues += value.y;       sumControl += control[i].y;     });      return (((sumValues - sumControl) / sumControl) * 100).toFixed(liftValPrec);   }    computePValue(values, control) {     const { pValPrec } = this.props;     // Compute the p-value from Student's t-test     // between two time series     let diffSum = 0;     let diffSqSum = 0;     let finiteCount = 0;     values.forEach((value, i) => {       const diff = control[i].y - value.y;       /* eslint-disable-next-line */       if (isFinite(diff)) {         finiteCount += 1;         diffSum += diff;         diffSqSum += diff * diff;       }     });     const tvalue = -Math.abs(       diffSum *         Math.sqrt(           (finiteCount - 1) / (finiteCount * diffSqSum - diffSum * diffSum),         ),     );     try {       return (2 * new dist.Studentt(finiteCount - 1).cdf(tvalue)).toFixed(         pValPrec,       ); // two-sided test     } catch (error) {       return NaN;     }   }    computeTTest(control) {     // Compute lift and p-values for each row     // against the selected control     const { data } = this.props;     const pValues = [];     const liftValues = [];     if (!data) {       return;     }     for (let i = 0; i < data.length; i += 1) {       if (i === control) {         pValues.push('control');         liftValues.push('control');       } else {         pValues.push(this.computePValue(data[i].values, data[control].values));         liftValues.push(this.computeLift(data[i].values, data[control].values));       }     }     this.setState({ control, liftValues, pValues });   }    render() {     const { data, metric, groups } = this.props;     const { control, liftValues, pValues } = this.state;      if (!Array.isArray(groups) || groups.length === 0) {       throw Error('Group by param is required');     }      // Render column header for each group     const columns = groups.map((group, i) => (       <Th key={i} column={group}>         {group}       </Th>     ));     const numGroups = groups.length;     // Columns for p-value, lift-value, and significance (true/false)     columns.push(       <Th key={numGroups + 1} column=""pValue"">         p-value       </Th>,     );     columns.push(       <Th key={numGroups + 2} column=""liftValue"">         Lift %       </Th>,     );     columns.push(       <Th key={numGroups + 3} column=""significant"">         Significant       </Th>,     );     const rows = data.map((entry, i) => {       const values = groups.map(         (           group,           j, // group names         ) => <Td key={j} column={group} data={entry.group[j]} />,       );       values.push(         <Td           key={numGroups + 1}           className={this.getPValueStatus(i)}           column=""pValue""           data={pValues[i]}         />,       );       values.push(         <Td           key={numGroups + 2}           className={this.getLiftStatus(i)}           column=""liftValue""           data={liftValues[i]}         />,       );       values.push(         <Td           key={numGroups + 3}           className={this.getSignificance(i).toString()}           column=""significant""           data={this.getSignificance(i)}         />,       );        return (         <Tr           key={i}           className={i === control ? 'control' : ''}           onClick={this.computeTTest.bind(this, i)}         >           {values}         </Tr>       );     });     // When sorted ascending, 'control' will always be at top     const sortConfig = groups.concat([       {         column: 'pValue',         sortFunction: (a, b) => {           if (a === 'control') {             return -1;           }           if (b === 'control') {             return 1;           }            return a > b ? 1 : -1; // p-values ascending         },       },       {         column: 'liftValue',         sortFunction: (a, b) => {           if (a === 'control') {             return -1;           }           if (b === 'control') {             return 1;           }            return parseFloat(a) > parseFloat(b) ? -1 : 1; // lift values descending         },       },       {         column: 'significant',         sortFunction: (a, b) => {           if (a === 'control') {             return -1;           }           if (b === 'control') {             return 1;           }            return a > b ? -1 : 1; // significant values first         },       },     ]);      return (       <div>         <h3>{metric}</h3>         <Table className=""table"" id={`table_${metric}`} sortable={sortConfig}>           <Thead>{columns}</Thead>           {rows}         </Table>       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_5_66.js
as_6_71,Inefficient Rendering,"export default class CategoricalDeckGLContainer extends React.PureComponent {   containerRef = React.createRef();    /*    * A Deck.gl container that handles categories.    *    * The container will have an interactive legend, populated from the    * categories present in the data.    */   constructor(props) {     super(props);     this.state = this.getStateFromProps(props);      this.getLayers = this.getLayers.bind(this);     this.onValuesChange = this.onValuesChange.bind(this);     this.toggleCategory = this.toggleCategory.bind(this);     this.showSingleCategory = this.showSingleCategory.bind(this);   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (nextProps.payload.form_data !== this.state.formData) {       this.setState({ ...this.getStateFromProps(nextProps) });     }   }    onValuesChange(values) {     this.setState({       values: Array.isArray(values)         ? values         : [values, values + this.state.getStep(values)],     });   }    // eslint-disable-next-line class-methods-use-this   getStateFromProps(props, state) {     const features = props.payload.data.features || [];     const timestamps = features.map(f => f.__timestamp);     const categories = getCategories(props.formData, features);      // the state is computed only from the payload; if it hasn't changed, do     // not recompute state since this would reset selections and/or the play     // slider position due to changes in form controls     if (state && props.payload.form_data === state.formData) {       return { ...state, categories };     }      // the granularity has to be read from the payload form_data, not the     // props formData which comes from the instantaneous controls state     const granularity =       props.payload.form_data.time_grain_sqla ||       props.payload.form_data.granularity ||       'P1D';      const { start, end, getStep, values, disabled } = getPlaySliderParams(       timestamps,       granularity,     );      const { width, height, formData } = props;     let { viewport } = props;     if (formData.autozoom) {       viewport = fitViewport(viewport, {         width,         height,         points: props.getPoints(features),       });     }     if (viewport.zoom < 0) {       viewport.zoom = 0;     }      return {       start,       end,       getStep,       values,       disabled,       viewport,       selected: [],       lastClick: 0,       formData: props.payload.form_data,       categories,     };   }    getLayers(values) {     const { getLayer, payload, formData: fd, onAddFilter } = this.props;     let features = payload.data.features ? [...payload.data.features] : [];      // Add colors from categories or fixed color     features = this.addColor(features, fd);      // Apply user defined data mutator if defined     if (fd.js_data_mutator) {       const jsFnMutator = sandboxedEval(fd.js_data_mutator);       features = jsFnMutator(features);     }      // Filter by time     if (values[0] === values[1] || values[1] === this.end) {       features = features.filter(         d => d.__timestamp >= values[0] && d.__timestamp <= values[1],       );     } else {       features = features.filter(         d => d.__timestamp >= values[0] && d.__timestamp < values[1],       );     }      // Show only categories selected in the legend     const cats = this.state.categories;     if (fd.dimension) {       features = features.filter(         d => cats[d.cat_color] && cats[d.cat_color].enabled,       );     }      const filteredPayload = {       ...payload,       data: { ...payload.data, features },     };      return [       getLayer(         fd,         filteredPayload,         onAddFilter,         this.setTooltip,         this.props.datasource,       ),     ];   }    // eslint-disable-next-line class-methods-use-this   addColor(data, fd) {     const c = fd.color_picker || { r: 0, g: 0, b: 0, a: 1 };     const colorFn = getScale(fd.color_scheme);      return data.map(d => {       let color;       if (fd.dimension) {         color = hexToRGB(colorFn(d.cat_color, fd.sliceId), c.a * 255);          return { ...d, color };       }        return d;     });   }    toggleCategory(category) {     const categoryState = this.state.categories[category];     const categories = {       ...this.state.categories,       [category]: {         ...categoryState,         enabled: !categoryState.enabled,       },     };      // if all categories are disabled, enable all -- similar to nvd3     if (Object.values(categories).every(v => !v.enabled)) {       /* eslint-disable no-param-reassign */       Object.values(categories).forEach(v => {         v.enabled = true;       });     }     this.setState({ categories });   }    showSingleCategory(category) {     const categories = { ...this.state.categories };     /* eslint-disable no-param-reassign */     Object.values(categories).forEach(v => {       v.enabled = false;     });     categories[category].enabled = true;     this.setState({ categories });   }    setTooltip = tooltip => {     const { current } = this.containerRef;     if (current) {       current.setTooltip(tooltip);     }   };    render() {     return (       <div style={{ position: 'relative' }}>         <AnimatableDeckGLContainer           ref={this.containerRef}           getLayers={this.getLayers}           start={this.state.start}           end={this.state.end}           getStep={this.state.getStep}           values={this.state.values}           disabled={this.state.disabled}           viewport={this.state.viewport}           mapboxApiAccessToken={this.props.mapboxApiKey}           mapStyle={this.props.formData.mapbox_style}           setControlValue={this.props.setControlValue}           width={this.props.width}           height={this.props.height}         >           <Legend             forceCategorical             categories={this.state.categories}             format={this.props.formData.legend_format}             position={this.props.formData.legend_position}             showSingleCategory={this.showSingleCategory}             toggleCategory={this.toggleCategory}           />         </AnimatableDeckGLContainer>       </div>     );   } }  CategoricalDeckGLContainer.propTypes = propTypes;",C:\Users\Owner\Desktop\DatasetFiles\as_6_71.js
as_7_73,Inefficient Rendering,"export default class PlaySlider extends React.PureComponent {   constructor(props) {     super(props);     this.state = { intervalId: null };      const range = props.end - props.start;     const frames = Math.min(props.maxFrames, range / props.step);     const width = range / frames;     this.intervalMilliseconds = props.loopDuration / frames;     this.increment =       width < props.step ? props.step : width - (width % props.step);      this.onChange = this.onChange.bind(this);     this.play = this.play.bind(this);     this.pause = this.pause.bind(this);     this.stepBackward = this.stepBackward.bind(this);     this.stepForward = this.stepForward.bind(this);     this.getPlayClass = this.getPlayClass.bind(this);     this.formatter = this.formatter.bind(this);   }    componentDidMount() {     Mousetrap.bind(['space'], this.play);   }    componentWillUnmount() {     Mousetrap.unbind(['space']);   }    onChange(event) {     this.props.onChange(event.target.value);     if (this.state.intervalId != null) {       this.pause();     }   }    getPlayClass() {     if (this.state.intervalId == null) {       return 'fa fa-play fa-lg slider-button';     }      return 'fa fa-pause fa-lg slider-button';   }    play() {     if (this.props.disabled) {       return;     }     if (this.state.intervalId != null) {       this.pause();     } else {       const id = setInterval(this.stepForward, this.intervalMilliseconds);       this.setState({ intervalId: id });     }   }    pause() {     clearInterval(this.state.intervalId);     this.setState({ intervalId: null });   }    stepForward() {     const { start, end, step, values, disabled } = this.props;      if (disabled) {       return;     }      const currentValues = Array.isArray(values)       ? values       : [values, values + step];     const nextValues = currentValues.map(value => value + this.increment);     const carriageReturn = nextValues[1] > end ? nextValues[0] - start : 0;      this.props.onChange(nextValues.map(value => value - carriageReturn));   }    stepBackward() {     const { start, end, step, values, disabled } = this.props;      if (disabled) {       return;     }      const currentValues = Array.isArray(values)       ? values       : [values, values + step];     const nextValues = currentValues.map(value => value - this.increment);     const carriageReturn = nextValues[0] < start ? end - nextValues[1] : 0;      this.props.onChange(nextValues.map(value => value + carriageReturn));   }    formatter(values) {     if (this.props.disabled) {       return t('Data has no time steps');     }      let parts = values;     if (!Array.isArray(values)) {       parts = [values];     } else if (values[0] === values[1]) {       parts = [values[0]];     }      return parts.map(value => new Date(value).toUTCString()).join(' : ');   }    render() {     const { start, end, step, orientation, reversed, disabled, range, values } =       this.props;      return (       <StyledSlider>         <div className=""play-slider-controls padded"">           <i             className=""fa fa-step-backward fa-lg slider-button ""             onClick={this.stepBackward}           />           <i className={this.getPlayClass()} onClick={this.play} />           <i             className=""fa fa-step-forward fa-lg slider-button ""             onClick={this.stepForward}           />         </div>         <div className=""play-slider-scrobbler padded"">           <BootstrapSliderWrapper             value={range ? values : values[0]}             range={range}             formatter={this.formatter}             change={this.onChange}             min={start}             max={end}             step={step}             orientation={orientation}             reversed={reversed}             disabled={disabled ? 'disabled' : 'enabled'}           />         </div>       </StyledSlider>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_7_73.js
as_8_76,Inefficient Rendering,"export class DeckGLContainer extends React.Component {   constructor(props) {     super(props);     this.tick = this.tick.bind(this);     this.onViewStateChange = this.onViewStateChange.bind(this);     // This has to be placed after this.tick is bound to this     this.state = {       timer: setInterval(this.tick, TICK),       tooltip: null,       viewState: props.viewport,     };   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (!isEqual(nextProps.viewport, this.props.viewport)) {       this.setState({ viewState: nextProps.viewport });     }   }    componentWillUnmount() {     clearInterval(this.state.timer);   }    onViewStateChange({ viewState }) {     this.setState({ viewState, lastUpdate: Date.now() });   }    tick() {     // Rate limiting updating viewport controls as it triggers lotsa renders     const { lastUpdate } = this.state;     if (lastUpdate && Date.now() - lastUpdate > TICK) {       const setCV = this.props.setControlValue;       if (setCV) {         setCV('viewport', this.state.viewState);       }       this.setState({ lastUpdate: null });     }   }    layers() {     // Support for layer factory     if (this.props.layers.some(l => typeof l === 'function')) {       return this.props.layers.map(l => (typeof l === 'function' ? l() : l));     }      return this.props.layers;   }    setTooltip = tooltip => {     this.setState({ tooltip });   };    render() {     const { children, bottomMargin, height, width } = this.props;     const { viewState, tooltip } = this.state;     const adjustedHeight = height - bottomMargin;      const layers = this.layers();      return (       <>         <div style={{ position: 'relative', width, height: adjustedHeight }}>           <DeckGL             initWebGLParameters             controller             width={width}             height={adjustedHeight}             layers={layers}             viewState={viewState}             glOptions={{ preserveDrawingBuffer: true }}             onViewStateChange={this.onViewStateChange}           >             <StaticMap               preserveDrawingBuffer               mapStyle={this.props.mapStyle}               mapboxApiAccessToken={this.props.mapboxApiAccessToken}             />           </DeckGL>           {children}         </div>         <Tooltip tooltip={tooltip} />       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_8_76.js
as_9_77,Props in initial state,"export class DeckGLContainer extends React.Component {   constructor(props) {     super(props);     this.tick = this.tick.bind(this);     this.onViewStateChange = this.onViewStateChange.bind(this);     // This has to be placed after this.tick is bound to this     this.state = {       timer: setInterval(this.tick, TICK),       tooltip: null,       viewState: props.viewport,     };   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (!isEqual(nextProps.viewport, this.props.viewport)) {       this.setState({ viewState: nextProps.viewport });     }   }    componentWillUnmount() {     clearInterval(this.state.timer);   }    onViewStateChange({ viewState }) {     this.setState({ viewState, lastUpdate: Date.now() });   }    tick() {     // Rate limiting updating viewport controls as it triggers lotsa renders     const { lastUpdate } = this.state;     if (lastUpdate && Date.now() - lastUpdate > TICK) {       const setCV = this.props.setControlValue;       if (setCV) {         setCV('viewport', this.state.viewState);       }       this.setState({ lastUpdate: null });     }   }    layers() {     // Support for layer factory     if (this.props.layers.some(l => typeof l === 'function')) {       return this.props.layers.map(l => (typeof l === 'function' ? l() : l));     }      return this.props.layers;   }    setTooltip = tooltip => {     this.setState({ tooltip });   };    render() {     const { children, bottomMargin, height, width } = this.props;     const { viewState, tooltip } = this.state;     const adjustedHeight = height - bottomMargin;      const layers = this.layers();      return (       <>         <div style={{ position: 'relative', width, height: adjustedHeight }}>           <DeckGL             initWebGLParameters             controller             width={width}             height={adjustedHeight}             layers={layers}             viewState={viewState}             glOptions={{ preserveDrawingBuffer: true }}             onViewStateChange={this.onViewStateChange}           >             <StaticMap               preserveDrawingBuffer               mapStyle={this.props.mapStyle}               mapboxApiAccessToken={this.props.mapboxApiAccessToken}             />           </DeckGL>           {children}         </div>         <Tooltip tooltip={tooltip} />       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_9_77.js
as_10_78,Inefficient Rendering,"type deckGLComponentProps = {   datasource: Datasource;   formData: QueryFormData;   height: number;   onAddFilter: () => void;   payload: JsonObject;   setControlValue: () => void;   viewport: Viewport;   width: number; }; export interface getLayerType<T> {   (     formData: QueryFormData,     payload: JsonObject,     onAddFilter: () => void,     setTooltip: (tooltip: string) => void,   ): T; } interface getPointsType<T> {   (point: number[]): T; } type deckGLComponentState = {   viewport: Viewport;   layer: unknown; };  export function createDeckGLComponent(   getLayer: getLayerType<unknown>,   getPoints: getPointsType<Point[]>, ): React.ComponentClass<deckGLComponentProps> {   // Higher order component   class Component extends React.PureComponent<     deckGLComponentProps,     deckGLComponentState   > {     containerRef: React.RefObject<DeckGLContainer> = React.createRef();      constructor(props: deckGLComponentProps) {       super(props);        const { width, height, formData } = props;       let { viewport } = props;       if (formData.autozoom) {         viewport = fitViewport(viewport, {           width,           height,           points: getPoints(props.payload.data.features),         }) as Viewport;       }        this.state = {         viewport,         layer: this.computeLayer(props),       };       this.onViewportChange = this.onViewportChange.bind(this);     }      UNSAFE_componentWillReceiveProps(nextProps: deckGLComponentProps) {       // Only recompute the layer if anything BUT the viewport has changed       const nextFdNoVP = { ...nextProps.formData, viewport: null };       const currFdNoVP = { ...this.props.formData, viewport: null };       if (         !isEqual(nextFdNoVP, currFdNoVP) ||         nextProps.payload !== this.props.payload       ) {         this.setState({ layer: this.computeLayer(nextProps) });       }     }      onViewportChange(viewport: Viewport) {       this.setState({ viewport });     }      computeLayer(props: deckGLComponentProps) {       const { formData, payload, onAddFilter } = props;        return getLayer(formData, payload, onAddFilter, this.setTooltip);     }      setTooltip = (tooltip: string) => {       const { current } = this.containerRef;       if (current) {         current?.setTooltip(tooltip);       }     };      render() {       const { formData, payload, setControlValue, height, width } = this.props;       const { layer, viewport } = this.state;        return (         <DeckGLContainerStyledWrapper           ref={this.containerRef}           mapboxApiAccessToken={payload.data.mapboxApiKey}           viewport={viewport}           layers={[layer]}           mapStyle={formData.mapbox_style}           setControlValue={setControlValue}           width={width}           height={height}           onViewportChange={this.onViewportChange}         />       );     }   }   return Component; }  export function createCategoricalDeckGLComponent(   getLayer: getLayerType<unknown>,   getPoints: getPointsType<Point[]>, ) {   return function Component(props: deckGLComponentProps) {     const {       datasource,       formData,       height,       payload,       setControlValue,       viewport,       width,     } = props;      return (       <CategoricalDeckGLContainer         datasource={datasource}         formData={formData}         mapboxApiKey={payload.data.mapboxApiKey}         setControlValue={setControlValue}         viewport={viewport}         getLayer={getLayer}         payload={payload}         getPoints={getPoints}         width={width}         height={height}       />     );   }; }",C:\Users\Owner\Desktop\DatasetFiles\as_10_78.js
as_11_81,Inefficient Rendering,"class DeckGLPolygon extends React.Component {   containerRef = React.createRef();    constructor(props) {     super(props);      this.state = DeckGLPolygon.getDerivedStateFromProps(props);      this.getLayers = this.getLayers.bind(this);     this.onSelect = this.onSelect.bind(this);     this.onValuesChange = this.onValuesChange.bind(this);   }    static getDerivedStateFromProps(props, state) {     const { width, height, formData, payload } = props;      // the state is computed only from the payload; if it hasn't changed, do     // not recompute state since this would reset selections and/or the play     // slider position due to changes in form controls     if (state && payload.form_data === state.formData) {       return null;     }      const features = payload.data.features || [];     const timestamps = features.map(f => f.__timestamp);      // the granularity has to be read from the payload form_data, not the     // props formData which comes from the instantaneous controls state     const granularity =       payload.form_data.time_grain_sqla ||       payload.form_data.granularity ||       'P1D';      const { start, end, getStep, values, disabled } = getPlaySliderParams(       timestamps,       granularity,     );      let { viewport } = props;     if (formData.autozoom) {       viewport = fitViewport(viewport, {         width,         height,         points: features.flatMap(getPointsFromPolygon),       });     }      return {       start,       end,       getStep,       values,       disabled,       viewport,       selected: [],       lastClick: 0,       formData: payload.form_data,     };   }    onSelect(polygon) {     const { formData, onAddFilter } = this.props;      const now = new Date();     const doubleClick = now - this.state.lastClick <= DOUBLE_CLICK_THRESHOLD;      // toggle selected polygons     const selected = [...this.state.selected];     if (doubleClick) {       selected.splice(0, selected.length, polygon);     } else if (formData.toggle_polygons) {       const i = selected.indexOf(polygon);       if (i === -1) {         selected.push(polygon);       } else {         selected.splice(i, 1);       }     } else {       selected.splice(0, 1, polygon);     }      this.setState({ selected, lastClick: now });     if (formData.table_filter) {       onAddFilter(formData.line_column, selected, false, true);     }   }    onValuesChange(values) {     this.setState({       values: Array.isArray(values)         ? values         : [values, values + this.state.getStep(values)],     });   }    getLayers(values) {     if (this.props.payload.data.features === undefined) {       return [];     }      const filters = [];      // time filter     if (values[0] === values[1] || values[1] === this.end) {       filters.push(         d => d.__timestamp >= values[0] && d.__timestamp <= values[1],       );     } else {       filters.push(         d => d.__timestamp >= values[0] && d.__timestamp < values[1],       );     }      const layer = getLayer(       this.props.formData,       this.props.payload,       this.props.onAddFilter,       this.setTooltip,       this.state.selected,       this.onSelect,       filters,     );      return [layer];   }    setTooltip = tooltip => {     const { current } = this.containerRef;     if (current) {       current.setTooltip(tooltip);     }   };    render() {     const { payload, formData, setControlValue } = this.props;     const { start, end, getStep, values, disabled, viewport } = this.state;      const fd = formData;     const metricLabel = fd.metric ? fd.metric.label || fd.metric : null;     const accessor = d => d[metricLabel];      const buckets = getBuckets(formData, payload.data.features, accessor);      return (       <div style={{ position: 'relative' }}>         <AnimatableDeckGLContainer           ref={this.containerRef}           aggregation           getLayers={this.getLayers}           start={start}           end={end}           getStep={getStep}           values={values}           disabled={disabled}           viewport={viewport}           width={this.props.width}           height={this.props.height}           mapboxApiAccessToken={payload.data.mapboxApiKey}           mapStyle={formData.mapbox_style}           setControlValue={setControlValue}           onValuesChange={this.onValuesChange}           onViewportChange={this.onViewportChange}         >           {formData.metric !== null && (             <Legend               categories={buckets}               position={formData.legend_position}               format={formData.legend_format}             />           )}         </AnimatableDeckGLContainer>       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_11_81.js
as_12_84,Inefficient Rendering,"class DeckGLScreenGrid extends React.PureComponent {   containerRef = React.createRef();    constructor(props) {     super(props);      this.state = DeckGLScreenGrid.getDerivedStateFromProps(props);      this.getLayers = this.getLayers.bind(this);     this.onValuesChange = this.onValuesChange.bind(this);   }    static getDerivedStateFromProps(props, state) {     // the state is computed only from the payload; if it hasn't changed, do     // not recompute state since this would reset selections and/or the play     // slider position due to changes in form controls     if (state && props.payload.form_data === state.formData) {       return null;     }      const features = props.payload.data.features || [];     const timestamps = features.map(f => f.__timestamp);      // the granularity has to be read from the payload form_data, not the     // props formData which comes from the instantaneous controls state     const granularity =       props.payload.form_data.time_grain_sqla ||       props.payload.form_data.granularity ||       'P1D';      const { start, end, getStep, values, disabled } = getPlaySliderParams(       timestamps,       granularity,     );     const { width, height, formData } = props;      let { viewport } = props;     if (formData.autozoom) {       viewport = fitViewport(viewport, {         width,         height,         points: getPoints(features),       });     }      return {       start,       end,       getStep,       values,       disabled,       viewport,       selected: [],       lastClick: 0,       formData: props.payload.form_data,     };   }    onValuesChange(values) {     this.setState({       values: Array.isArray(values)         ? values         : // eslint-disable-next-line react/no-access-state-in-setstate           [values, values + this.state.getStep(values)],     });   }    getLayers(values) {     const filters = [];      // time filter     if (values[0] === values[1] || values[1] === this.end) {       filters.push(         d => d.__timestamp >= values[0] && d.__timestamp <= values[1],       );     } else {       filters.push(         d => d.__timestamp >= values[0] && d.__timestamp < values[1],       );     }      const layer = getLayer(       this.props.formData,       this.props.payload,       this.props.onAddFilter,       this.setTooltip,       filters,     );      return [layer];   }    setTooltip = tooltip => {     const { current } = this.containerRef;     if (current) {       current.setTooltip(tooltip);     }   };    render() {     const { formData, payload, setControlValue } = this.props;      return (       <div>         <AnimatableDeckGLContainer           ref={this.containerRef}           aggregation           getLayers={this.getLayers}           start={this.state.start}           end={this.state.end}           getStep={this.state.getStep}           values={this.state.values}           disabled={this.state.disabled}           viewport={this.state.viewport}           width={this.props.width}           height={this.props.height}           mapboxApiAccessToken={payload.data.mapboxApiKey}           mapStyle={formData.mapbox_style}           setControlValue={setControlValue}           onValuesChange={this.onValuesChange}           onViewportChange={this.onViewportChange}         />       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_12_84.js
as_13_86,Inefficient Rendering,"class DeckMulti extends React.PureComponent {   containerRef = React.createRef();    constructor(props) {     super(props);     this.state = { subSlicesLayers: {} };     this.onViewportChange = this.onViewportChange.bind(this);   }    componentDidMount() {     const { formData, payload } = this.props;     this.loadLayers(formData, payload);   }    UNSAFE_componentWillReceiveProps(nextProps) {     const { formData, payload } = nextProps;     const hasChanges = !_.isEqual(       this.props.formData.deck_slices,       nextProps.formData.deck_slices,     );     if (hasChanges) {       this.loadLayers(formData, payload);     }   }    onViewportChange(viewport) {     this.setState({ viewport });   }    loadLayers(formData, payload, viewport) {     this.setState({ subSlicesLayers: {}, viewport });     payload.data.slices.forEach(subslice => {       // Filters applied to multi_deck are passed down to underlying charts       // note that dashboard contextual information (filter_immune_slices and such) aren't       // taken into consideration here       const filters = [         ...(subslice.form_data.filters || []),         ...(formData.filters || []),         ...(formData.extra_filters || []),       ];       const subsliceCopy = {         ...subslice,         form_data: {           ...subslice.form_data,           filters,         },       };        SupersetClient.get({         endpoint: getExploreLongUrl(subsliceCopy.form_data, 'json'),       })         .then(({ json }) => {           const layer = layerGenerators[subsliceCopy.form_data.viz_type](             subsliceCopy.form_data,             json,             this.props.onAddFilter,             this.setTooltip,             [],             this.props.onSelect,           );           this.setState({             subSlicesLayers: {               ...this.state.subSlicesLayers,               [subsliceCopy.slice_id]: layer,             },           });         })         .catch(() => {});     });   }    setTooltip = tooltip => {     const { current } = this.containerRef;     if (current) {       current.setTooltip(tooltip);     }   };    render() {     const { payload, formData, setControlValue, height, width } = this.props;     const { subSlicesLayers } = this.state;      const layers = Object.values(subSlicesLayers);      return (       <DeckGLContainerStyledWrapper         ref={this.containerRef}         mapboxApiAccessToken={payload.data.mapboxApiKey}         viewport={this.state.viewport || this.props.viewport}         layers={layers}         mapStyle={formData.mapbox_style}         setControlValue={setControlValue}         onViewportChange={this.onViewportChange}         height={height}         width={width}       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_13_86.js
as_14_89,Inefficient Rendering,"class BigNumberVis extends React.PureComponent<BigNumberVizProps> {   static defaultProps = {     className: '',     headerFormatter: defaultNumberFormatter,     formatTime: smartDateVerboseFormatter,     headerFontSize: PROPORTION.HEADER,     kickerFontSize: PROPORTION.KICKER,     mainColor: BRAND_COLOR,     showTimestamp: false,     showTrendLine: false,     startYAxisAtZero: true,     subheader: '',     subheaderFontSize: PROPORTION.SUBHEADER,     timeRangeFixed: false,   };    getClassName() {     const { className, showTrendLine, bigNumberFallback } = this.props;     const names = `superset-legacy-chart-big-number ${className} ${       bigNumberFallback ? 'is-fallback-value' : ''     }`;     if (showTrendLine) return names;     return `${names} no-trendline`;   }    createTemporaryContainer() {     const container = document.createElement('div');     container.className = this.getClassName();     container.style.position = 'absolute'; // so it won't disrupt page layout     container.style.opacity = '0'; // and not visible     return container;   }    renderFallbackWarning() {     const { bigNumberFallback, formatTime, showTimestamp } = this.props;     if (!formatTime || !bigNumberFallback || showTimestamp) return null;     return (       <span         className=""alert alert-warning""         role=""alert""         title={t(           `Last available value seen on %s`,           formatTime(bigNumberFallback[0]),         )}       >         {t('Not up to date')}       </span>     );   }    renderKicker(maxHeight: number) {     const { timestamp, showTimestamp, formatTime, width } = this.props;     if (       !formatTime ||       !showTimestamp ||       typeof timestamp === 'string' ||       typeof timestamp === 'boolean'     )       return null;      const text = timestamp === null ? '' : formatTime(timestamp);      const container = this.createTemporaryContainer();     document.body.append(container);     const fontSize = computeMaxFontSize({       text,       maxWidth: width,       maxHeight,       className: 'kicker',       container,     });     container.remove();      return (       <div         className=""kicker""         style={{           fontSize,           height: maxHeight,         }}       >         {text}       </div>     );   }    renderHeader(maxHeight: number) {     const { bigNumber, headerFormatter, width, colorThresholdFormatters } =       this.props;     // @ts-ignore     const text = bigNumber === null ? t('No data') : headerFormatter(bigNumber);      const hasThresholdColorFormatter =       Array.isArray(colorThresholdFormatters) &&       colorThresholdFormatters.length > 0;      let numberColor;     if (hasThresholdColorFormatter) {       colorThresholdFormatters!.forEach(formatter => {         const formatterResult = bigNumber           ? formatter.getColorFromValue(bigNumber as number)           : false;         if (formatterResult) {           numberColor = formatterResult;         }       });     } else {       numberColor = 'black';     }      const container = this.createTemporaryContainer();     document.body.append(container);     const fontSize = computeMaxFontSize({       text,       maxWidth: width - 8, // Decrease 8px for more precise font size       maxHeight,       className: 'header-line',       container,     });     container.remove();      const onContextMenu = (e: MouseEvent<HTMLDivElement>) => {       if (this.props.onContextMenu) {         e.preventDefault();         this.props.onContextMenu(e.nativeEvent.clientX, e.nativeEvent.clientY);       }     };      return (       <div         className=""header-line""         style={{           fontSize,           height: maxHeight,           color: numberColor,         }}         onContextMenu={onContextMenu}       >         {text}       </div>     );   }    renderSubheader(maxHeight: number) {     const { bigNumber, subheader, width, bigNumberFallback } = this.props;     let fontSize = 0;      const NO_DATA_OR_HASNT_LANDED = t(       'No data after filtering or data is NULL for the latest time record',     );     const NO_DATA = t(       'Try applying different filters or ensuring your datasource has data',     );     let text = subheader;     if (bigNumber === null) {       text = bigNumberFallback ? NO_DATA : NO_DATA_OR_HASNT_LANDED;     }     if (text) {       const container = this.createTemporaryContainer();       document.body.append(container);       fontSize = computeMaxFontSize({         text,         maxWidth: width,         maxHeight,         className: 'subheader-line',         container,       });       container.remove();        return (         <div           className=""subheader-line""           style={{             fontSize,             height: maxHeight,           }}         >           {text}         </div>       );     }     return null;   }    renderTrendline(maxHeight: number) {     const { width, trendLineData, echartOptions, refs } = this.props;      // if can't find any non-null values, no point rendering the trendline     if (!trendLineData?.some(d => d[1] !== null)) {       return null;     }      const eventHandlers: EventHandlers = {       contextmenu: eventParams => {         if (this.props.onContextMenu) {           eventParams.event.stop();           const { data } = eventParams;           if (data) {             const pointerEvent = eventParams.event.event;             const drillToDetailFilters: BinaryQueryObjectFilterClause[] = [];             drillToDetailFilters.push({               col: this.props.formData?.granularitySqla,               grain: this.props.formData?.timeGrainSqla,               op: '==',               val: data[0],               formattedVal: this.props.xValueFormatter?.(data[0]),             });             this.props.onContextMenu(               pointerEvent.clientX,               pointerEvent.clientY,               { drillToDetail: drillToDetailFilters },             );           }         }       },     };      return (       echartOptions && (         <Echart           refs={refs}           width={Math.floor(width)}           height={maxHeight}           echartOptions={echartOptions}           eventHandlers={eventHandlers}         />       )     );   }    render() {     const {       showTrendLine,       height,       kickerFontSize,       headerFontSize,       subheaderFontSize,     } = this.props;     const className = this.getClassName();      if (showTrendLine) {       const chartHeight = Math.floor(PROPORTION.TRENDLINE * height);       const allTextHeight = height - chartHeight;        return (         <div className={className}>           <div className=""text-container"" style={{ height: allTextHeight }}>             {this.renderFallbackWarning()}             {this.renderKicker(               Math.ceil(                 (kickerFontSize || 0) * (1 - PROPORTION.TRENDLINE) * height,               ),             )}             {this.renderHeader(               Math.ceil(headerFontSize * (1 - PROPORTION.TRENDLINE) * height),             )}             {this.renderSubheader(               Math.ceil(                 subheaderFontSize * (1 - PROPORTION.TRENDLINE) * height,               ),             )}           </div>           {this.renderTrendline(chartHeight)}         </div>       );     }      return (       <div className={className} style={{ height }}>         {this.renderFallbackWarning()}         {this.renderKicker((kickerFontSize || 0) * height)}         {this.renderHeader(Math.ceil(headerFontSize * height))}         {this.renderSubheader(Math.ceil(subheaderFontSize * height))}       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_14_89.js
as_15_90,Inefficient Rendering,"class BigNumberVis extends React.PureComponent<BigNumberVizProps> {   static defaultProps = {     className: '',     headerFormatter: defaultNumberFormatter,     formatTime: smartDateVerboseFormatter,     headerFontSize: PROPORTION.HEADER,     kickerFontSize: PROPORTION.KICKER,     mainColor: BRAND_COLOR,     showTimestamp: false,     showTrendLine: false,     startYAxisAtZero: true,     subheader: '',     subheaderFontSize: PROPORTION.SUBHEADER,     timeRangeFixed: false,   };    getClassName() {     const { className, showTrendLine, bigNumberFallback } = this.props;     const names = `superset-legacy-chart-big-number ${className} ${       bigNumberFallback ? 'is-fallback-value' : ''     }`;     if (showTrendLine) return names;     return `${names} no-trendline`;   }    createTemporaryContainer() {     const container = document.createElement('div');     container.className = this.getClassName();     container.style.position = 'absolute'; // so it won't disrupt page layout     container.style.opacity = '0'; // and not visible     return container;   }    renderFallbackWarning() {     const { bigNumberFallback, formatTime, showTimestamp } = this.props;     if (!formatTime || !bigNumberFallback || showTimestamp) return null;     return (       <span         className=""alert alert-warning""         role=""alert""         title={t(           `Last available value seen on %s`,           formatTime(bigNumberFallback[0]),         )}       >         {t('Not up to date')}       </span>     );   }    renderKicker(maxHeight: number) {     const { timestamp, showTimestamp, formatTime, width } = this.props;     if (       !formatTime ||       !showTimestamp ||       typeof timestamp === 'string' ||       typeof timestamp === 'boolean'     )       return null;      const text = timestamp === null ? '' : formatTime(timestamp);      const container = this.createTemporaryContainer();     document.body.append(container);     const fontSize = computeMaxFontSize({       text,       maxWidth: width,       maxHeight,       className: 'kicker',       container,     });     container.remove();      return (       <div         className=""kicker""         style={{           fontSize,           height: maxHeight,         }}       >         {text}       </div>     );   }    renderHeader(maxHeight: number) {     const { bigNumber, headerFormatter, width, colorThresholdFormatters } =       this.props;     // @ts-ignore     const text = bigNumber === null ? t('No data') : headerFormatter(bigNumber);      const hasThresholdColorFormatter =       Array.isArray(colorThresholdFormatters) &&       colorThresholdFormatters.length > 0;      let numberColor;     if (hasThresholdColorFormatter) {       colorThresholdFormatters!.forEach(formatter => {         const formatterResult = bigNumber           ? formatter.getColorFromValue(bigNumber as number)           : false;         if (formatterResult) {           numberColor = formatterResult;         }       });     } else {       numberColor = 'black';     }      const container = this.createTemporaryContainer();     document.body.append(container);     const fontSize = computeMaxFontSize({       text,       maxWidth: width - 8, // Decrease 8px for more precise font size       maxHeight,       className: 'header-line',       container,     });     container.remove();      const onContextMenu = (e: MouseEvent<HTMLDivElement>) => {       if (this.props.onContextMenu) {         e.preventDefault();         this.props.onContextMenu(e.nativeEvent.clientX, e.nativeEvent.clientY);       }     };      return (       <div         className=""header-line""         style={{           fontSize,           height: maxHeight,           color: numberColor,         }}         onContextMenu={onContextMenu}       >         {text}       </div>     );   }    renderSubheader(maxHeight: number) {     const { bigNumber, subheader, width, bigNumberFallback } = this.props;     let fontSize = 0;      const NO_DATA_OR_HASNT_LANDED = t(       'No data after filtering or data is NULL for the latest time record',     );     const NO_DATA = t(       'Try applying different filters or ensuring your datasource has data',     );     let text = subheader;     if (bigNumber === null) {       text = bigNumberFallback ? NO_DATA : NO_DATA_OR_HASNT_LANDED;     }     if (text) {       const container = this.createTemporaryContainer();       document.body.append(container);       fontSize = computeMaxFontSize({         text,         maxWidth: width,         maxHeight,         className: 'subheader-line',         container,       });       container.remove();        return (         <div           className=""subheader-line""           style={{             fontSize,             height: maxHeight,           }}         >           {text}         </div>       );     }     return null;   }    renderTrendline(maxHeight: number) {     const { width, trendLineData, echartOptions, refs } = this.props;      // if can't find any non-null values, no point rendering the trendline     if (!trendLineData?.some(d => d[1] !== null)) {       return null;     }      const eventHandlers: EventHandlers = {       contextmenu: eventParams => {         if (this.props.onContextMenu) {           eventParams.event.stop();           const { data } = eventParams;           if (data) {             const pointerEvent = eventParams.event.event;             const drillToDetailFilters: BinaryQueryObjectFilterClause[] = [];             drillToDetailFilters.push({               col: this.props.formData?.granularitySqla,               grain: this.props.formData?.timeGrainSqla,               op: '==',               val: data[0],               formattedVal: this.props.xValueFormatter?.(data[0]),             });             this.props.onContextMenu(               pointerEvent.clientX,               pointerEvent.clientY,               { drillToDetail: drillToDetailFilters },             );           }         }       },     };      return (       echartOptions && (         <Echart           refs={refs}           width={Math.floor(width)}           height={maxHeight}           echartOptions={echartOptions}           eventHandlers={eventHandlers}         />       )     );   }    render() {     const {       showTrendLine,       height,       kickerFontSize,       headerFontSize,       subheaderFontSize,     } = this.props;     const className = this.getClassName();      if (showTrendLine) {       const chartHeight = Math.floor(PROPORTION.TRENDLINE * height);       const allTextHeight = height - chartHeight;        return (         <div className={className}>           <div className=""text-container"" style={{ height: allTextHeight }}>             {this.renderFallbackWarning()}             {this.renderKicker(               Math.ceil(                 (kickerFontSize || 0) * (1 - PROPORTION.TRENDLINE) * height,               ),             )}             {this.renderHeader(               Math.ceil(headerFontSize * (1 - PROPORTION.TRENDLINE) * height),             )}             {this.renderSubheader(               Math.ceil(                 subheaderFontSize * (1 - PROPORTION.TRENDLINE) * height,               ),             )}           </div>           {this.renderTrendline(chartHeight)}         </div>       );     }      return (       <div className={className} style={{ height }}>         {this.renderFallbackWarning()}         {this.renderKicker((kickerFontSize || 0) * height)}         {this.renderHeader(Math.ceil(headerFontSize * height))}         {this.renderSubheader(Math.ceil(subheaderFontSize * height))}       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_15_90.js
as_16_103,Inefficient Rendering,"export const HandlebarsViewer = ({   templateSource,   data, }: HandlebarsViewerProps) => {   const [renderedTemplate, setRenderedTemplate] = useState('');   const [error, setError] = useState('');   const appContainer = document.getElementById('app');   const { common } = JSON.parse(     appContainer?.getAttribute('data-bootstrap') || '{}',   );   const htmlSanitization = common?.conf?.HTML_SANITIZATION ?? true;   const htmlSchemaOverrides =     common?.conf?.HTML_SANITIZATION_SCHEMA_EXTENSIONS || {};    useMemo(() => {     try {       const template = Handlebars.compile(templateSource);       const result = template(data);       setRenderedTemplate(result);       setError('');     } catch (error) {       setRenderedTemplate('');       setError(error.message);     }   }, [templateSource, data]);    const Error = styled.pre`     white-space: pre-wrap;   `;    if (error) {     return <Error>{error}</Error>;   }    if (renderedTemplate) {     return (       <SafeMarkdown         source={renderedTemplate}         htmlSanitization={htmlSanitization}         htmlSchemaOverrides={htmlSchemaOverrides}       />     );   }   return <p>{t('Loading...')}</p>; };  //  usage: {{dateFormat my_date format=""MMMM YYYY""}} Handlebars.registerHelper('dateFormat', function (context, block) {   const f = block.hash.format || 'YYYY-MM-DD';   return moment(context).format(f); });  // usage: {{  }} Handlebars.registerHelper('stringify', (obj: any, obj2: any) => {   // calling without an argument   if (obj2 === undefined)     throw Error('Please call with an object. Example: `stringify myObj`');   return isPlainObject(obj) ? JSON.stringify(obj) : String(obj); });",C:\Users\Owner\Desktop\DatasetFiles\as_16_103.js
as_17_108,Inefficient Rendering,"export class TableRenderer extends React.Component {   constructor(props) {     super(props);      // We need state to record which entries are collapsed and which aren't.     // This is an object with flat-keys indicating if the corresponding rows     // should be collapsed.     this.state = { collapsedRows: {}, collapsedCols: {} };      this.clickHeaderHandler = this.clickHeaderHandler.bind(this);     this.clickHandler = this.clickHandler.bind(this);   }    getBasePivotSettings() {     // One-time extraction of pivot settings that we'll use throughout the render.      const { props } = this;     const colAttrs = props.cols;     const rowAttrs = props.rows;      const tableOptions = {       rowTotals: true,       colTotals: true,       ...props.tableOptions,     };     const rowTotals = tableOptions.rowTotals || colAttrs.length === 0;     const colTotals = tableOptions.colTotals || rowAttrs.length === 0;      const namesMapping = props.namesMapping || {};     const subtotalOptions = {       arrowCollapsed: '\u25B2',       arrowExpanded: '\u25BC',       ...props.subtotalOptions,     };      const colSubtotalDisplay = {       displayOnTop: false,       enabled: rowTotals,       hideOnExpand: false,       ...subtotalOptions.colSubtotalDisplay,     };      const rowSubtotalDisplay = {       displayOnTop: false,       enabled: colTotals,       hideOnExpand: false,       ...subtotalOptions.rowSubtotalDisplay,     };      const pivotData = new PivotData(props, {       rowEnabled: rowSubtotalDisplay.enabled,       colEnabled: colSubtotalDisplay.enabled,       rowPartialOnTop: rowSubtotalDisplay.displayOnTop,       colPartialOnTop: colSubtotalDisplay.displayOnTop,     });     const rowKeys = pivotData.getRowKeys();     const colKeys = pivotData.getColKeys();      // Also pre-calculate all the callbacks for cells, etc... This is nice to have to     // avoid re-calculations of the call-backs on cell expansions, etc...     const cellCallbacks = {};     const rowTotalCallbacks = {};     const colTotalCallbacks = {};     let grandTotalCallback = null;     if (tableOptions.clickCallback) {       rowKeys.forEach(rowKey => {         const flatRowKey = flatKey(rowKey);         if (!(flatRowKey in cellCallbacks)) {           cellCallbacks[flatRowKey] = {};         }         colKeys.forEach(colKey => {           cellCallbacks[flatRowKey][flatKey(colKey)] = this.clickHandler(             pivotData,             rowKey,             colKey,           );         });       });        // Add in totals as well.       if (rowTotals) {         rowKeys.forEach(rowKey => {           rowTotalCallbacks[flatKey(rowKey)] = this.clickHandler(             pivotData,             rowKey,             [],           );         });       }       if (colTotals) {         colKeys.forEach(colKey => {           colTotalCallbacks[flatKey(colKey)] = this.clickHandler(             pivotData,             [],             colKey,           );         });       }       if (rowTotals && colTotals) {         grandTotalCallback = this.clickHandler(pivotData, [], []);       }     }      return {       pivotData,       colAttrs,       rowAttrs,       colKeys,       rowKeys,       rowTotals,       colTotals,       arrowCollapsed: subtotalOptions.arrowCollapsed,       arrowExpanded: subtotalOptions.arrowExpanded,       colSubtotalDisplay,       rowSubtotalDisplay,       cellCallbacks,       rowTotalCallbacks,       colTotalCallbacks,       grandTotalCallback,       namesMapping,     };   }    clickHandler(pivotData, rowValues, colValues) {     const colAttrs = this.props.cols;     const rowAttrs = this.props.rows;     const value = pivotData.getAggregator(rowValues, colValues).value();     const filters = {};     const colLimit = Math.min(colAttrs.length, colValues.length);     for (let i = 0; i < colLimit; i += 1) {       const attr = colAttrs[i];       if (colValues[i] !== null) {         filters[attr] = colValues[i];       }     }     const rowLimit = Math.min(rowAttrs.length, rowValues.length);     for (let i = 0; i < rowLimit; i += 1) {       const attr = rowAttrs[i];       if (rowValues[i] !== null) {         filters[attr] = rowValues[i];       }     }     return e =>       this.props.tableOptions.clickCallback(e, value, filters, pivotData);   }    clickHeaderHandler(     pivotData,     values,     attrs,     attrIdx,     callback,     isSubtotal = false,     isGrandTotal = false,   ) {     const filters = {};     for (let i = 0; i <= attrIdx; i += 1) {       const attr = attrs[i];       filters[attr] = values[i];     }     return e =>       callback(         e,         values[attrIdx],         filters,         pivotData,         isSubtotal,         isGrandTotal,       );   }    collapseAttr(rowOrCol, attrIdx, allKeys) {     return e => {       // Collapse an entire attribute.       e.stopPropagation();       const keyLen = attrIdx + 1;       const collapsed = allKeys.filter(k => k.length === keyLen).map(flatKey);        const updates = {};       collapsed.forEach(k => {         updates[k] = true;       });        if (rowOrCol) {         this.setState(state => ({           collapsedRows: { ...state.collapsedRows, ...updates },         }));       } else {         this.setState(state => ({           collapsedCols: { ...state.collapsedCols, ...updates },         }));       }     };   }    expandAttr(rowOrCol, attrIdx, allKeys) {     return e => {       // Expand an entire attribute. This implicitly implies expanding all of the       // parents as well. It's a bit inefficient but ah well...       e.stopPropagation();       const updates = {};       allKeys.forEach(k => {         for (let i = 0; i <= attrIdx; i += 1) {           updates[flatKey(k.slice(0, i + 1))] = false;         }       });        if (rowOrCol) {         this.setState(state => ({           collapsedRows: { ...state.collapsedRows, ...updates },         }));       } else {         this.setState(state => ({           collapsedCols: { ...state.collapsedCols, ...updates },         }));       }     };   }    toggleRowKey(flatRowKey) {     return e => {       e.stopPropagation();       this.setState(state => ({         collapsedRows: {           ...state.collapsedRows,           [flatRowKey]: !state.collapsedRows[flatRowKey],         },       }));     };   }    toggleColKey(flatColKey) {     return e => {       e.stopPropagation();       this.setState(state => ({         collapsedCols: {           ...state.collapsedCols,           [flatColKey]: !state.collapsedCols[flatColKey],         },       }));     };   }    calcAttrSpans(attrArr, numAttrs) {     // Given an array of attribute values (i.e. each element is another array with     // the value at every level), compute the spans for every attribute value at     // every level. The return value is a nested array of the same shape. It has     // -1's for repeated values and the span number otherwise.      const spans = [];     // Index of the last new value     const li = Array(numAttrs).map(() => 0);     let lv = Array(numAttrs).map(() => null);     for (let i = 0; i < attrArr.length; i += 1) {       // Keep increasing span values as long as the last keys are the same. For       // the rest, record spans of 1. Update the indices too.       const cv = attrArr[i];       const ent = [];       let depth = 0;       const limit = Math.min(lv.length, cv.length);       while (depth < limit && lv[depth] === cv[depth]) {         ent.push(-1);         spans[li[depth]][depth] += 1;         depth += 1;       }       while (depth < cv.length) {         li[depth] = i;         ent.push(1);         depth += 1;       }       spans.push(ent);       lv = cv;     }     return spans;   }    renderColHeaderRow(attrName, attrIdx, pivotSettings) {     // Render a single row in the column header at the top of the pivot table.      const {       rowAttrs,       colAttrs,       colKeys,       visibleColKeys,       colAttrSpans,       rowTotals,       arrowExpanded,       arrowCollapsed,       colSubtotalDisplay,       maxColVisible,       pivotData,       namesMapping,     } = pivotSettings;     const {       highlightHeaderCellsOnHover,       omittedHighlightHeaderGroups = [],       highlightedHeaderCells,       dateFormatters,     } = this.props.tableOptions;      const spaceCell =       attrIdx === 0 && rowAttrs.length !== 0 ? (         <th           key=""padding""           colSpan={rowAttrs.length}           rowSpan={colAttrs.length}           aria-hidden=""true""         />       ) : null;      const needToggle =       colSubtotalDisplay.enabled && attrIdx !== colAttrs.length - 1;     let arrowClickHandle = null;     let subArrow = null;     if (needToggle) {       arrowClickHandle =         attrIdx + 1 < maxColVisible           ? this.collapseAttr(false, attrIdx, colKeys)           : this.expandAttr(false, attrIdx, colKeys);       subArrow = attrIdx + 1 < maxColVisible ? arrowExpanded : arrowCollapsed;     }     const attrNameCell = (       <th key=""label"" className=""pvtAxisLabel"">         {displayHeaderCell(           needToggle,           subArrow,           arrowClickHandle,           attrName,           namesMapping,         )}       </th>     );      const attrValueCells = [];     const rowIncrSpan = rowAttrs.length !== 0 ? 1 : 0;     // Iterate through columns. Jump over duplicate values.     let i = 0;     while (i < visibleColKeys.length) {       let handleContextMenu;       const colKey = visibleColKeys[i];       const colSpan = attrIdx < colKey.length ? colAttrSpans[i][attrIdx] : 1;       let colLabelClass = 'pvtColLabel';       if (attrIdx < colKey.length) {         if (!omittedHighlightHeaderGroups.includes(colAttrs[attrIdx])) {           if (highlightHeaderCellsOnHover) {             colLabelClass += ' hoverable';           }           handleContextMenu = e =>             this.props.onContextMenu(e, colKey, undefined, {               [attrName]: colKey[attrIdx],             });         }         if (           highlightedHeaderCells &&           Array.isArray(highlightedHeaderCells[colAttrs[attrIdx]]) &&           highlightedHeaderCells[colAttrs[attrIdx]].includes(colKey[attrIdx])         ) {           colLabelClass += ' active';         }          const rowSpan = 1 + (attrIdx === colAttrs.length - 1 ? rowIncrSpan : 0);         const flatColKey = flatKey(colKey.slice(0, attrIdx + 1));         const onArrowClick = needToggle ? this.toggleColKey(flatColKey) : null;          const headerCellFormattedValue =           dateFormatters &&           dateFormatters[attrName] &&           typeof dateFormatters[attrName] === 'function'             ? dateFormatters[attrName](colKey[attrIdx])             : colKey[attrIdx];         attrValueCells.push(           <th             className={colLabelClass}             key={`colKey-${flatColKey}`}             colSpan={colSpan}             rowSpan={rowSpan}             onClick={this.clickHeaderHandler(               pivotData,               colKey,               this.props.cols,               attrIdx,               this.props.tableOptions.clickColumnHeaderCallback,             )}             onContextMenu={handleContextMenu}           >             {displayHeaderCell(               needToggle,               this.state.collapsedCols[flatColKey]                 ? arrowCollapsed                 : arrowExpanded,               onArrowClick,               headerCellFormattedValue,               namesMapping,             )}           </th>,         );       } else if (attrIdx === colKey.length) {         const rowSpan = colAttrs.length - colKey.length + rowIncrSpan;         attrValueCells.push(           <th             className={`${colLabelClass} pvtSubtotalLabel`}             key={`colKeyBuffer-${flatKey(colKey)}`}             colSpan={colSpan}             rowSpan={rowSpan}             onClick={this.clickHeaderHandler(               pivotData,               colKey,               this.props.cols,               attrIdx,               this.props.tableOptions.clickColumnHeaderCallback,               true,             )}           >             {t('Subtotal')}           </th>,         );       }       // The next colSpan columns will have the same value anyway...       i += colSpan;     }      const totalCell =       attrIdx === 0 && rowTotals ? (         <th           key=""total""           className=""pvtTotalLabel""           rowSpan={colAttrs.length + Math.min(rowAttrs.length, 1)}           onClick={this.clickHeaderHandler(             pivotData,             [],             this.props.cols,             attrIdx,             this.props.tableOptions.clickColumnHeaderCallback,             false,             true,           )}         >           {t('Total (%(aggregatorName)s)', {             aggregatorName: t(this.props.aggregatorName),           })}         </th>       ) : null;      const cells = [spaceCell, attrNameCell, ...attrValueCells, totalCell];     return <tr key={`colAttr-${attrIdx}`}>{cells}</tr>;   }    renderRowHeaderRow(pivotSettings) {     // Render just the attribute names of the rows (the actual attribute values     // will show up in the individual rows).      const {       rowAttrs,       colAttrs,       rowKeys,       arrowCollapsed,       arrowExpanded,       rowSubtotalDisplay,       maxRowVisible,       pivotData,       namesMapping,     } = pivotSettings;     return (       <tr key=""rowHdr"">         {rowAttrs.map((r, i) => {           const needLabelToggle =             rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;           let arrowClickHandle = null;           let subArrow = null;           if (needLabelToggle) {             arrowClickHandle =               i + 1 < maxRowVisible                 ? this.collapseAttr(true, i, rowKeys)                 : this.expandAttr(true, i, rowKeys);             subArrow = i + 1 < maxRowVisible ? arrowExpanded : arrowCollapsed;           }           return (             <th className=""pvtAxisLabel"" key={`rowAttr-${i}`}>               {displayHeaderCell(                 needLabelToggle,                 subArrow,                 arrowClickHandle,                 r,                 namesMapping,               )}             </th>           );         })}         <th           className=""pvtTotalLabel""           key=""padding""           onClick={this.clickHeaderHandler(             pivotData,             [],             this.props.rows,             0,             this.props.tableOptions.clickRowHeaderCallback,             false,             true,           )}         >           {colAttrs.length === 0             ? t('Total (%(aggregatorName)s)', {                 aggregatorName: t(this.props.aggregatorName),               })             : null}         </th>       </tr>     );   }    renderTableRow(rowKey, rowIdx, pivotSettings) {     // Render a single row in the pivot table.      const {       rowAttrs,       colAttrs,       rowAttrSpans,       visibleColKeys,       pivotData,       rowTotals,       rowSubtotalDisplay,       arrowExpanded,       arrowCollapsed,       cellCallbacks,       rowTotalCallbacks,       namesMapping,     } = pivotSettings;      const {       highlightHeaderCellsOnHover,       omittedHighlightHeaderGroups = [],       highlightedHeaderCells,       cellColorFormatters,       dateFormatters,     } = this.props.tableOptions;     const flatRowKey = flatKey(rowKey);      const colIncrSpan = colAttrs.length !== 0 ? 1 : 0;     const attrValueCells = rowKey.map((r, i) => {       let handleContextMenu;       let valueCellClassName = 'pvtRowLabel';       if (!omittedHighlightHeaderGroups.includes(rowAttrs[i])) {         if (highlightHeaderCellsOnHover) {           valueCellClassName += ' hoverable';         }         handleContextMenu = e =>           this.props.onContextMenu(e, undefined, rowKey, {             [rowAttrs[i]]: r,           });       }       if (         highlightedHeaderCells &&         Array.isArray(highlightedHeaderCells[rowAttrs[i]]) &&         highlightedHeaderCells[rowAttrs[i]].includes(r)       ) {         valueCellClassName += ' active';       }       const rowSpan = rowAttrSpans[rowIdx][i];       if (rowSpan > 0) {         const flatRowKey = flatKey(rowKey.slice(0, i + 1));         const colSpan = 1 + (i === rowAttrs.length - 1 ? colIncrSpan : 0);         const needRowToggle =           rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;         const onArrowClick = needRowToggle           ? this.toggleRowKey(flatRowKey)           : null;          const headerCellFormattedValue =           dateFormatters && dateFormatters[rowAttrs[i]]             ? dateFormatters[rowAttrs[i]](r)             : r;         return (           <th             key={`rowKeyLabel-${i}`}             className={valueCellClassName}             rowSpan={rowSpan}             colSpan={colSpan}             onClick={this.clickHeaderHandler(               pivotData,               rowKey,               this.props.rows,               i,               this.props.tableOptions.clickRowHeaderCallback,             )}             onContextMenu={handleContextMenu}           >             {displayHeaderCell(               needRowToggle,               this.state.collapsedRows[flatRowKey]                 ? arrowCollapsed                 : arrowExpanded,               onArrowClick,               headerCellFormattedValue,               namesMapping,             )}           </th>         );       }       return null;     });      const attrValuePaddingCell =       rowKey.length < rowAttrs.length ? (         <th           className=""pvtRowLabel pvtSubtotalLabel""           key=""rowKeyBuffer""           colSpan={rowAttrs.length - rowKey.length + colIncrSpan}           rowSpan={1}           onClick={this.clickHeaderHandler(             pivotData,             rowKey,             this.props.rows,             rowKey.length,             this.props.tableOptions.clickRowHeaderCallback,             true,           )}         >           {t('Subtotal')}         </th>       ) : null;      const rowClickHandlers = cellCallbacks[flatRowKey] || {};     const valueCells = visibleColKeys.map(colKey => {       const flatColKey = flatKey(colKey);       const agg = pivotData.getAggregator(rowKey, colKey);       const aggValue = agg.value();        const keys = [...rowKey, ...colKey];       let backgroundColor;       if (cellColorFormatters) {         Object.values(cellColorFormatters).forEach(cellColorFormatter => {           if (Array.isArray(cellColorFormatter)) {             keys.forEach(key => {               if (backgroundColor) {                 return;               }               cellColorFormatter                 .filter(formatter => formatter.column === key)                 .forEach(formatter => {                   const formatterResult = formatter.getColorFromValue(aggValue);                   if (formatterResult) {                     backgroundColor = formatterResult;                   }                 });             });           }         });       }        const style = agg.isSubtotal         ? { fontWeight: 'bold' }         : { backgroundColor };        return (         <td           role=""gridcell""           className=""pvtVal""           key={`pvtVal-${flatColKey}`}           onClick={rowClickHandlers[flatColKey]}           onContextMenu={e => this.props.onContextMenu(e, colKey, rowKey)}           style={style}         >           {agg.format(aggValue)}         </td>       );     });      let totalCell = null;     if (rowTotals) {       const agg = pivotData.getAggregator(rowKey, []);       const aggValue = agg.value();       totalCell = (         <td           role=""gridcell""           key=""total""           className=""pvtTotal""           onClick={rowTotalCallbacks[flatRowKey]}           onContextMenu={e => this.props.onContextMenu(e, undefined, rowKey)}         >           {agg.format(aggValue)}         </td>       );     }      const rowCells = [       ...attrValueCells,       attrValuePaddingCell,       ...valueCells,       totalCell,     ];      return <tr key={`keyRow-${flatRowKey}`}>{rowCells}</tr>;   }    renderTotalsRow(pivotSettings) {     // Render the final totals rows that has the totals for all the columns.      const {       rowAttrs,       colAttrs,       visibleColKeys,       rowTotals,       pivotData,       colTotalCallbacks,       grandTotalCallback,     } = pivotSettings;      const totalLabelCell = (       <th         key=""label""         className=""pvtTotalLabel pvtRowTotalLabel""         colSpan={rowAttrs.length + Math.min(colAttrs.length, 1)}         onClick={this.clickHeaderHandler(           pivotData,           [],           this.props.rows,           0,           this.props.tableOptions.clickRowHeaderCallback,           false,           true,         )}       >         {t('Total (%(aggregatorName)s)', {           aggregatorName: t(this.props.aggregatorName),         })}       </th>     );      const totalValueCells = visibleColKeys.map(colKey => {       const flatColKey = flatKey(colKey);       const agg = pivotData.getAggregator([], colKey);       const aggValue = agg.value();        return (         <td           role=""gridcell""           className=""pvtTotal pvtRowTotal""           key={`total-${flatColKey}`}           onClick={colTotalCallbacks[flatColKey]}           onContextMenu={e => this.props.onContextMenu(e, colKey, undefined)}           style={{ padding: '5px' }}         >           {agg.format(aggValue)}         </td>       );     });      let grandTotalCell = null;     if (rowTotals) {       const agg = pivotData.getAggregator([], []);       const aggValue = agg.value();       grandTotalCell = (         <td           role=""gridcell""           key=""total""           className=""pvtGrandTotal pvtRowTotal""           onClick={grandTotalCallback}           onContextMenu={e => this.props.onContextMenu(e, undefined, undefined)}         >           {agg.format(aggValue)}         </td>       );     }      const totalCells = [totalLabelCell, ...totalValueCells, grandTotalCell];      return (       <tr key=""total"" className=""pvtRowTotals"">         {totalCells}       </tr>     );   }    visibleKeys(keys, collapsed, numAttrs, subtotalDisplay) {     return keys.filter(       key =>         // Is the key hidden by one of its parents?         !key.some((k, j) => collapsed[flatKey(key.slice(0, j))]) &&         // Leaf key.         (key.length === numAttrs ||           // Children hidden. Must show total.           flatKey(key) in collapsed ||           // Don't hide totals.           !subtotalDisplay.hideOnExpand),     );   }    isDashboardEditMode() {     return document.contains(document.querySelector('.dashboard--editing'));   }    render() {     if (this.cachedProps !== this.props) {       this.cachedProps = this.props;       this.cachedBasePivotSettings = this.getBasePivotSettings();     }     const {       colAttrs,       rowAttrs,       rowKeys,       colKeys,       colTotals,       rowSubtotalDisplay,       colSubtotalDisplay,     } = this.cachedBasePivotSettings;      // Need to account for exclusions to compute the effective row     // and column keys.     const visibleRowKeys = this.visibleKeys(       rowKeys,       this.state.collapsedRows,       rowAttrs.length,       rowSubtotalDisplay,     );     const visibleColKeys = this.visibleKeys(       colKeys,       this.state.collapsedCols,       colAttrs.length,       colSubtotalDisplay,     );      const pivotSettings = {       visibleRowKeys,       maxRowVisible: Math.max(...visibleRowKeys.map(k => k.length)),       visibleColKeys,       maxColVisible: Math.max(...visibleColKeys.map(k => k.length)),       rowAttrSpans: this.calcAttrSpans(visibleRowKeys, rowAttrs.length),       colAttrSpans: this.calcAttrSpans(visibleColKeys, colAttrs.length),       ...this.cachedBasePivotSettings,     };      return (       <Styles isDashboardEditMode={this.isDashboardEditMode()}>         <table className=""pvtTable"" role=""grid"">           <thead>             {colAttrs.map((c, j) =>               this.renderColHeaderRow(c, j, pivotSettings),             )}             {rowAttrs.length !== 0 && this.renderRowHeaderRow(pivotSettings)}           </thead>           <tbody>             {visibleRowKeys.map((r, i) =>               this.renderTableRow(r, i, pivotSettings),             )}             {colTotals && this.renderTotalsRow(pivotSettings)}           </tbody>         </table>       </Styles>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_17_108.js
as_18_114,Inefficient Rendering,"class WordCloud extends React.PureComponent<   FullWordCloudProps,   WordCloudState > {   static defaultProps = defaultProps;    // Cannot name it isMounted because of conflict   // with React's component function name   isComponentMounted = false;    wordCloudEncoderFactory = createEncoderFactory<WordCloudEncodingConfig>({     channelTypes: {       color: 'Color',       fontFamily: 'Category',       fontSize: 'Numeric',       fontWeight: 'Category',       text: 'Text',     },     defaultEncoding: {       color: { value: this.props.theme.colors.grayscale.dark2 },       fontFamily: { value: this.props.theme.typography.families.sansSerif },       fontSize: { value: 20 },       fontWeight: { value: 'bold' },       text: { value: '' },     },   });    createEncoder = this.wordCloudEncoderFactory.createSelector();    constructor(props: FullWordCloudProps) {     super(props);     this.state = {       words: [],       scaleFactor: 1,     };     this.setWords = this.setWords.bind(this);   }    componentDidMount() {     this.isComponentMounted = true;     this.update();   }    componentDidUpdate(prevProps: WordCloudProps) {     const { data, encoding, width, height, rotation } = this.props;      if (       !isEqual(prevProps.data, data) ||       !isEqual(prevProps.encoding, encoding) ||       prevProps.width !== width ||       prevProps.height !== height ||       prevProps.rotation !== rotation     ) {       this.update();     }   }    componentWillUnmount() {     this.isComponentMounted = false;   }    setWords(words: Word[]) {     if (this.isComponentMounted) {       this.setState({ words });     }   }    update() {     const { data, encoding } = this.props;      const encoder = this.createEncoder(encoding);     encoder.setDomainFromDataset(data);      const sortedData = [...data].sort(       (a, b) =>         encoder.channels.fontSize.encodeDatum(b, 0) -         encoder.channels.fontSize.encodeDatum(a, 0),     );     const topResultsCount = Math.max(       sortedData.length * TOP_RESULTS_PERCENTAGE,       10,     );     const topResults = sortedData.slice(0, topResultsCount);      // Ensure top results are always included in the final word cloud by scaling chart down if needed     this.generateCloud(encoder, 1, (words: Word[]) =>       topResults.every((d: PlainObject) =>         words.find(           ({ text }) => encoder.channels.text.getValueFromDatum(d) === text,         ),       ),     );   }    generateCloud(     encoder: Encoder<WordCloudEncodingConfig>,     scaleFactor: number,     isValid: (word: Word[]) => boolean,   ) {     const { data, width, height, rotation } = this.props;      cloudLayout()       .size([width * scaleFactor, height * scaleFactor])       // clone the data because cloudLayout mutates input       .words(data.map(d => ({ ...d })))       .padding(5)       .rotate(ROTATION[rotation] || ROTATION.flat)       .text(d => encoder.channels.text.getValueFromDatum(d))       .font(d =>         encoder.channels.fontFamily.encodeDatum(           d,           this.props.theme.typography.families.sansSerif,         ),       )       .fontWeight(d => encoder.channels.fontWeight.encodeDatum(d, 'normal'))       .fontSize(d => encoder.channels.fontSize.encodeDatum(d, 0))       .on('end', (words: Word[]) => {         if (isValid(words) || scaleFactor > MAX_SCALE_FACTOR) {           if (this.isComponentMounted) {             this.setState({ words, scaleFactor });           }         } else {           this.generateCloud(encoder, scaleFactor + SCALE_FACTOR_STEP, isValid);         }       })       .start();   }    render() {     const { scaleFactor } = this.state;     const { width, height, encoding, sliceId } = this.props;     const { words } = this.state;      const encoder = this.createEncoder(encoding);     encoder.channels.color.setDomainFromDataset(words);      const { getValueFromDatum } = encoder.channels.color;     const colorFn = encoder.channels.color.scale as CategoricalColorScale;      const viewBoxWidth = width * scaleFactor;     const viewBoxHeight = height * scaleFactor;      return (       <svg         width={width}         height={height}         viewBox={`-${viewBoxWidth / 2} -${           viewBoxHeight / 2         } ${viewBoxWidth} ${viewBoxHeight}`}       >         <g>           {words.map(w => (             <text               key={w.text}               fontSize={`${w.size}px`}               fontWeight={w.weight}               fontFamily={w.font}               fill={colorFn(getValueFromDatum(w) as string, sliceId)}               textAnchor=""middle""               transform={`translate(${w.x}, ${w.y}) rotate(${w.rotate})`}             >               {w.text}             </text>           ))}         </g>       </svg>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_18_114.js
as_19_128,Inefficient Rendering,"export default class AlteredSliceTag extends React.Component {   constructor(props) {     super(props);     const diffs = this.getDiffs(props);     const controlsMap = getControlsForVizType(this.props.origFormData.viz_type);     const rows = this.getRowsFromDiffs(diffs, controlsMap);      this.state = { rows, hasDiffs: !isEmpty(diffs), controlsMap };   }    UNSAFE_componentWillReceiveProps(newProps) {     // Update differences if need be     if (isEqual(this.props, newProps)) {       return;     }     const diffs = this.getDiffs(newProps);     this.setState(prevState => ({       rows: this.getRowsFromDiffs(diffs, prevState.controlsMap),       hasDiffs: !isEmpty(diffs),     }));   }    getRowsFromDiffs(diffs, controlsMap) {     return Object.entries(diffs).map(([key, diff]) => ({       control: (controlsMap[key] && controlsMap[key].label) || key,       before: this.formatValue(diff.before, key, controlsMap),       after: this.formatValue(diff.after, key, controlsMap),     }));   }    getDiffs(props) {     // Returns all properties that differ in the     // current form data and the saved form data     const ofd = sanitizeFormData(props.origFormData);     const cfd = sanitizeFormData(props.currentFormData);      const fdKeys = Object.keys(cfd);     const diffs = {};     fdKeys.forEach(fdKey => {       if (!ofd[fdKey] && !cfd[fdKey]) {         return;       }       if (['filters', 'having', 'having_filters', 'where'].includes(fdKey)) {         return;       }       if (!this.isEqualish(ofd[fdKey], cfd[fdKey])) {         diffs[fdKey] = { before: ofd[fdKey], after: cfd[fdKey] };       }     });     return diffs;   }    isEqualish(val1, val2) {     return isEqual(alterForComparison(val1), alterForComparison(val2));   }    formatValue(value, key, controlsMap) {     // Format display value based on the control type     // or the value type     if (value === undefined) {       return 'N/A';     }     if (value === null) {       return 'null';     }     if (controlsMap[key]?.type === 'AdhocFilterControl') {       if (!value.length) {         return '[]';       }       return value         .map(v => {           const filterVal =             v.comparator && v.comparator.constructor === Array               ? `[${v.comparator.join(', ')}]`               : v.comparator;           return `${v.subject} ${v.operator} ${filterVal}`;         })         .join(', ');     }     if (controlsMap[key]?.type === 'BoundsControl') {       return `Min: ${value[0]}, Max: ${value[1]}`;     }     if (controlsMap[key]?.type === 'CollectionControl') {       return value.map(v => safeStringify(v)).join(', ');     }     if (       controlsMap[key]?.type === 'MetricsControl' &&       value.constructor === Array     ) {       const formattedValue = value.map(v => v?.label ?? v);       return formattedValue.length ? formattedValue.join(', ') : '[]';     }     if (typeof value === 'boolean') {       return value ? 'true' : 'false';     }     if (value.constructor === Array) {       const formattedValue = value.map(v => v?.label ?? v);       return formattedValue.length ? formattedValue.join(', ') : '[]';     }     if (typeof value === 'string' || typeof value === 'number') {       return value;     }     return safeStringify(value);   }    renderModalBody() {     const columns = [       {         accessor: 'control',         Header: t('Control'),       },       {         accessor: 'before',         Header: t('Before'),       },       {         accessor: 'after',         Header: t('After'),       },     ];     // set the wrap text in the specific columns.     const columnsForWrapText = ['Control', 'Before', 'After'];      return (       <TableView         columns={columns}         data={this.state.rows}         pageSize={50}         className=""table-condensed""         columnsForWrapText={columnsForWrapText}       />     );   }    renderTriggerNode() {     return (       <Tooltip id=""difference-tooltip"" title={t('Click to see difference')}>         <StyledLabel className=""label"">{t('Altered')}</StyledLabel>       </Tooltip>     );   }    render() {     // Return nothing if there are no differences     if (!this.state.hasDiffs) {       return null;     }     // Render the label-warning 'Altered' tag which the user may     // click to open a modal containing a table summarizing the     // differences in the slice     return (       <ModalTrigger         triggerNode={this.renderTriggerNode()}         modalTitle={t('Chart changes')}         modalBody={this.renderModalBody()}         responsive       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_19_128.js
as_20_133,Inefficient Rendering,"class Chart extends React.PureComponent {   constructor(props) {     super(props);     this.handleRenderContainerFailure =       this.handleRenderContainerFailure.bind(this);   }    componentDidMount() {     if (this.props.triggerQuery) {       this.runQuery();     }   }    componentDidUpdate() {     if (this.props.triggerQuery) {       this.runQuery();     }   }    runQuery() {     if (this.props.chartId > 0 && isFeatureEnabled(FeatureFlag.CLIENT_CACHE)) {       // Load saved chart with a GET request       this.props.actions.getSavedChart(         this.props.formData,         this.props.force || getUrlParam(URL_PARAMS.force), // allow override via url params force=true         this.props.timeout,         this.props.chartId,         this.props.dashboardId,         this.props.ownState,       );     } else {       // Create chart with POST request       this.props.actions.postChartFormData(         this.props.formData,         this.props.force || getUrlParam(URL_PARAMS.force), // allow override via url params force=true         this.props.timeout,         this.props.chartId,         this.props.dashboardId,         this.props.ownState,       );     }   }    handleRenderContainerFailure(error, info) {     const { actions, chartId } = this.props;     logging.warn(error);     actions.chartRenderingFailed(       error.toString(),       chartId,       info ? info.componentStack : null,     );      actions.logEvent(LOG_ACTIONS_RENDER_CHART, {       slice_id: chartId,       has_err: true,       error_details: error.toString(),       start_offset: this.renderStartTime,       ts: new Date().getTime(),       duration: Logger.getTimestamp() - this.renderStartTime,     });   }    renderErrorMessage(queryResponse) {     const {       chartId,       chartAlert,       chartStackTrace,       datasource,       dashboardId,       height,       datasetsStatus,     } = this.props;     const error = queryResponse?.errors?.[0];     const message = chartAlert || queryResponse?.message;      // if datasource is still loading, don't render JS errors     if (       chartAlert !== undefined &&       chartAlert !== NONEXISTENT_DATASET &&       datasource === PLACEHOLDER_DATASOURCE &&       datasetsStatus !== ResourceStatus.ERROR     ) {       return (         <Styles           key={chartId}           data-ui-anchor=""chart""           className=""chart-container""           data-test=""chart-container""           height={height}         >           <Loading />         </Styles>       );     }      return (       <ChartErrorMessage         key={chartId}         chartId={chartId}         error={error}         subtitle={<MonospaceDiv>{message}</MonospaceDiv>}         copyText={message}         link={queryResponse ? queryResponse.link : null}         source={dashboardId ? ChartSource.Dashboard : ChartSource.Explore}         stackTrace={chartStackTrace}       />     );   }    render() {     const {       height,       chartAlert,       chartStatus,       errorMessage,       chartIsStale,       queriesResponse = [],       width,     } = this.props;      const isLoading = chartStatus === 'loading';     this.renderContainerStartTime = Logger.getTimestamp();     if (chartStatus === 'failed') {       return queriesResponse.map(item => this.renderErrorMessage(item));     }      if (errorMessage && ensureIsArray(queriesResponse).length === 0) {       return (         <EmptyStateBig           title={t('Add required control values to preview chart')}           description={getChartRequiredFieldsMissingMessage(true)}           image=""chart.svg""         />       );     }      if (       !isLoading &&       !chartAlert &&       !errorMessage &&       chartIsStale &&       ensureIsArray(queriesResponse).length === 0     ) {       return (         <EmptyStateBig           title={t('Your chart is ready to go!')}           description={             <span>               {t(                 'Click on ""Create chart"" button in the control panel on the left to preview a visualization or',               )}{' '}               <span role=""button"" tabIndex={0} onClick={this.props.onQuery}>                 {t('click here')}               </span>               .             </span>           }           image=""chart.svg""         />       );     }      return (       <ErrorBoundary         onError={this.handleRenderContainerFailure}         showMessage={false}       >         <Styles           data-ui-anchor=""chart""           className=""chart-container""           data-test=""chart-container""           height={height}           width={width}         >           <div className=""slice_container"" data-test=""slice-container"">             {this.props.isInView ||             !isFeatureEnabled(FeatureFlag.DASHBOARD_VIRTUALIZATION) ||             isCurrentUserBot() ? (               <ChartRenderer                 {...this.props}                 source={this.props.dashboardId ? 'dashboard' : 'explore'}                 data-test={this.props.vizType}               />             ) : (               <Loading />             )}           </div>           {isLoading && <Loading />}         </Styles>       </ErrorBoundary>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_20_133.js
as_21_138,Inefficient Rendering,"class ChartRenderer extends React.Component {   constructor(props) {     super(props);     this.state = {       showContextMenu:         props.source === ChartSource.Dashboard &&         (isFeatureEnabled(FeatureFlag.DRILL_TO_DETAIL) ||           isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)),       inContextMenu: false,     };     this.hasQueryResponseChange = false;      this.contextMenuRef = React.createRef();      this.handleAddFilter = this.handleAddFilter.bind(this);     this.handleRenderSuccess = this.handleRenderSuccess.bind(this);     this.handleRenderFailure = this.handleRenderFailure.bind(this);     this.handleSetControlValue = this.handleSetControlValue.bind(this);     this.handleOnContextMenu = this.handleOnContextMenu.bind(this);     this.handleContextMenuSelected = this.handleContextMenuSelected.bind(this);     this.handleContextMenuClosed = this.handleContextMenuClosed.bind(this);     this.onContextMenuFallback = this.onContextMenuFallback.bind(this);      this.hooks = {       onAddFilter: this.handleAddFilter,       onContextMenu: this.state.showContextMenu         ? this.handleOnContextMenu         : undefined,       onError: this.handleRenderFailure,       setControlValue: this.handleSetControlValue,       onFilterMenuOpen: this.props.onFilterMenuOpen,       onFilterMenuClose: this.props.onFilterMenuClose,       setDataMask: dataMask => {         this.props.actions?.updateDataMask(this.props.chartId, dataMask);       },     };      // TODO: queriesResponse comes from Redux store but it's being edited by     // the plugins, hence we need to clone it to avoid state mutation     // until we change the reducers to use Redux Toolkit with Immer     this.mutableQueriesResponse = cloneDeep(this.props.queriesResponse);   }    shouldComponentUpdate(nextProps, nextState) {     const resultsReady =       nextProps.queriesResponse &&       ['success', 'rendered'].indexOf(nextProps.chartStatus) > -1 &&       !nextProps.queriesResponse?.[0]?.error;      if (resultsReady) {       if (!isEqual(this.state, nextState)) {         return true;       }       this.hasQueryResponseChange =         nextProps.queriesResponse !== this.props.queriesResponse;        if (this.hasQueryResponseChange) {         this.mutableQueriesResponse = cloneDeep(nextProps.queriesResponse);       }        return (         this.hasQueryResponseChange ||         !isEqual(nextProps.datasource, this.props.datasource) ||         nextProps.annotationData !== this.props.annotationData ||         nextProps.ownState !== this.props.ownState ||         nextProps.filterState !== this.props.filterState ||         nextProps.height !== this.props.height ||         nextProps.width !== this.props.width ||         nextProps.triggerRender ||         nextProps.labelColors !== this.props.labelColors ||         nextProps.sharedLabelColors !== this.props.sharedLabelColors ||         nextProps.formData.color_scheme !== this.props.formData.color_scheme ||         nextProps.formData.stack !== this.props.formData.stack ||         nextProps.cacheBusterProp !== this.props.cacheBusterProp ||         nextProps.emitCrossFilters !== this.props.emitCrossFilters       );     }     return false;   }    handleAddFilter(col, vals, merge = true, refresh = true) {     this.props.addFilter(col, vals, merge, refresh);   }    handleRenderSuccess() {     const { actions, chartStatus, chartId, vizType } = this.props;     if (['loading', 'rendered'].indexOf(chartStatus) < 0) {       actions.chartRenderingSucceeded(chartId);     }      // only log chart render time which is triggered by query results change     // currently we don't log chart re-render time, like window resize etc     if (this.hasQueryResponseChange) {       actions.logEvent(LOG_ACTIONS_RENDER_CHART, {         slice_id: chartId,         viz_type: vizType,         start_offset: this.renderStartTime,         ts: new Date().getTime(),         duration: Logger.getTimestamp() - this.renderStartTime,       });     }   }    handleRenderFailure(error, info) {     const { actions, chartId } = this.props;     logging.warn(error);     actions.chartRenderingFailed(       error.toString(),       chartId,       info ? info.componentStack : null,     );      // only trigger render log when query is changed     if (this.hasQueryResponseChange) {       actions.logEvent(LOG_ACTIONS_RENDER_CHART, {         slice_id: chartId,         has_err: true,         error_details: error.toString(),         start_offset: this.renderStartTime,         ts: new Date().getTime(),         duration: Logger.getTimestamp() - this.renderStartTime,       });     }   }    handleSetControlValue(...args) {     const { setControlValue } = this.props;     if (setControlValue) {       setControlValue(...args);     }   }    handleOnContextMenu(offsetX, offsetY, filters) {     this.contextMenuRef.current.open(offsetX, offsetY, filters);     this.setState({ inContextMenu: true });   }    handleContextMenuSelected() {     this.setState({ inContextMenu: false });   }    handleContextMenuClosed() {     this.setState({ inContextMenu: false });   }    // When viz plugins don't handle `contextmenu` event, fallback handler   // calls `handleOnContextMenu` with no `filters` param.   onContextMenuFallback(event) {     if (!this.state.inContextMenu) {       event.preventDefault();       this.handleOnContextMenu(event.clientX, event.clientY);     }   }    render() {     const { chartAlert, chartStatus, chartId, emitCrossFilters } = this.props;      // Skip chart rendering     if (chartStatus === 'loading' || !!chartAlert || chartStatus === null) {       return null;     }      this.renderStartTime = Logger.getTimestamp();      const {       width,       height,       datasource,       annotationData,       initialValues,       ownState,       filterState,       chartIsStale,       formData,       latestQueryFormData,       postTransformProps,     } = this.props;      const currentFormData =       chartIsStale && latestQueryFormData ? latestQueryFormData : formData;     const vizType = currentFormData.viz_type || this.props.vizType;      // It's bad practice to use unprefixed `vizType` as classnames for chart     // container. It may cause css conflicts as in the case of legacy table chart.     // When migrating charts, we should gradually add a `superset-chart-` prefix     // to each one of them.     const snakeCaseVizType = snakeCase(vizType);     const chartClassName =       vizType === 'table'         ? `superset-chart-${snakeCaseVizType}`         : snakeCaseVizType;      const webpackHash =       process.env.WEBPACK_MODE === 'development'         ? `-${             // eslint-disable-next-line camelcase             typeof __webpack_require__ !== 'undefined' &&             // eslint-disable-next-line camelcase, no-undef             typeof __webpack_require__.h === 'function' &&             // eslint-disable-next-line no-undef             __webpack_require__.h()           }`         : '';      let noResultsComponent;     const noResultTitle = t('No results were returned for this query');     const noResultDescription =       this.props.source === ChartSource.Explore         ? t(             'Make sure that the controls are configured properly and the datasource contains data for the selected time range',           )         : undefined;     const noResultImage = 'chart.svg';     if (width > BIG_NO_RESULT_MIN_WIDTH && height > BIG_NO_RESULT_MIN_HEIGHT) {       noResultsComponent = (         <EmptyStateBig           title={noResultTitle}           description={noResultDescription}           image={noResultImage}         />       );     } else {       noResultsComponent = (         <EmptyStateSmall title={noResultTitle} image={noResultImage} />       );     }      // Check for Behavior.DRILL_TO_DETAIL to tell if chart can receive Drill to     // Detail props or if it'll cause side-effects (e.g. excessive re-renders).     const drillToDetailProps = getChartMetadataRegistry()       .get(formData.viz_type)       ?.behaviors.find(behavior => behavior === Behavior.DRILL_TO_DETAIL)       ? { inContextMenu: this.state.inContextMenu }       : {};      return (       <>         {this.state.showContextMenu && (           <ChartContextMenu             ref={this.contextMenuRef}             id={chartId}             formData={currentFormData}             onSelection={this.handleContextMenuSelected}             onClose={this.handleContextMenuClosed}           />         )}         <div           onContextMenu={             this.state.showContextMenu ? this.onContextMenuFallback : undefined           }         >           <SuperChart             disableErrorBoundary             key={`${chartId}${webpackHash}`}             id={`chart-id-${chartId}`}             className={chartClassName}             chartType={vizType}             width={width}             height={height}             annotationData={annotationData}             datasource={datasource}             initialValues={initialValues}             formData={currentFormData}             ownState={ownState}             filterState={filterState}             hooks={this.hooks}             behaviors={behaviors}             queriesData={this.mutableQueriesResponse}             onRenderSuccess={this.handleRenderSuccess}             onRenderFailure={this.handleRenderFailure}             noResults={noResultsComponent}             postTransformProps={postTransformProps}             emitCrossFilters={emitCrossFilters}             {...drillToDetailProps}           />         </div>       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_21_138.js
as_22_145,Inefficient Rendering,"class CopyToClipboard extends React.Component {   constructor(props) {     super(props);      // bindings     this.copyToClipboard = this.copyToClipboard.bind(this);     this.onClick = this.onClick.bind(this);   }    onClick() {     if (this.props.getText) {       this.props.getText(d => {         this.copyToClipboard(Promise.resolve(d));       });     } else {       this.copyToClipboard(Promise.resolve(this.props.text));     }   }    getDecoratedCopyNode() {     return React.cloneElement(this.props.copyNode, {       style: { cursor: 'pointer' },       onClick: this.onClick,     });   }    copyToClipboard(textToCopy) {     copyTextToClipboard(() => textToCopy)       .then(() => {         this.props.addSuccessToast(t('Copied to clipboard!'));       })       .catch(() => {         this.props.addDangerToast(           t(             'Sorry, your browser does not support copying. Use Ctrl / Cmd + C!',           ),         );       })       .finally(() => {         this.props.onCopyEnd();       });   }    renderTooltip(cursor) {     return (       <>         {!this.props.hideTooltip ? (           <Tooltip             id=""copy-to-clipboard-tooltip""             placement=""topRight""             style={{ cursor }}             title={this.props.tooltipText}             trigger={['hover']}             arrowPointAtCenter           >             {this.getDecoratedCopyNode()}           </Tooltip>         ) : (           this.getDecoratedCopyNode()         )}       </>     );   }    renderNotWrapped() {     return this.renderTooltip('pointer');   }    renderLink() {     return (       <span css={{ display: 'inline-flex', alignItems: 'center' }}>         {this.props.shouldShowText && this.props.text && (           <span className=""m-r-5"" data-test=""short-url"">             {this.props.text}           </span>         )}         {this.renderTooltip()}       </span>     );   }    render() {     const { wrapped } = this.props;     if (!wrapped) {       return this.renderNotWrapped();     }     return this.renderLink();   } }",C:\Users\Owner\Desktop\DatasetFiles\as_22_145.js
as_23_152,Inefficient Rendering,"export default class CRUDCollection extends React.PureComponent<   CRUDCollectionProps,   CRUDCollectionState > {   constructor(props: CRUDCollectionProps) {     super(props);      const { collection, collectionArray } = createKeyedCollection(       props.collection,     );     this.state = {       expandedColumns: {},       collection,       collectionArray,       sortColumn: '',       sort: 0,     };     this.renderItem = this.renderItem.bind(this);     this.onAddItem = this.onAddItem.bind(this);     this.renderExpandableSection = this.renderExpandableSection.bind(this);     this.getLabel = this.getLabel.bind(this);     this.onFieldsetChange = this.onFieldsetChange.bind(this);     this.renderTableBody = this.renderTableBody.bind(this);     this.changeCollection = this.changeCollection.bind(this);     this.sortColumn = this.sortColumn.bind(this);     this.renderSortIcon = this.renderSortIcon.bind(this);   }    UNSAFE_componentWillReceiveProps(nextProps: CRUDCollectionProps) {     if (nextProps.collection !== this.props.collection) {       const { collection, collectionArray } = createKeyedCollection(         nextProps.collection,       );       this.setState({         collection,         collectionArray,       });     }   }    onCellChange(id: number, col: string, val: boolean) {     this.changeCollection({       ...this.state.collection,       [id]: {         ...this.state.collection[id],         [col]: val,       },     });   }    onAddItem() {     if (this.props.itemGenerator) {       let newItem = this.props.itemGenerator();       if (!newItem.id) {         newItem = { ...newItem, id: shortid.generate() };       }       this.changeCollection(this.state.collection, newItem);     }   }    onFieldsetChange(item: any) {     this.changeCollection({       ...this.state.collection,       [item.id]: item,     });   }    getLabel(col: any) {     const { columnLabels } = this.props;     let label = columnLabels?.[col] ? columnLabels[col] : col;     if (label.startsWith('__')) {       // special label-free columns (ie: caret for expand, delete cross)       label = '';     }     return label;   }    changeCollection(collection: any, newItem?: object) {     this.setState({ collection });     if (this.props.onChange) {       const collectionArray = this.state.collectionArray         .map((c: { id: number }) => collection[c.id])         // filter out removed items         .filter(c => c !== undefined);        if (newItem) {         collectionArray.unshift(newItem);       }       this.props.onChange(collectionArray);     }   }    deleteItem(id: number) {     const newColl = { ...this.state.collection };     delete newColl[id];     this.changeCollection(newColl);   }    effectiveTableColumns() {     const { tableColumns, allowDeletes, expandFieldset } = this.props;     const cols = allowDeletes       ? tableColumns.concat(['__actions'])       : tableColumns;     return expandFieldset ? ['__expand'].concat(cols) : cols;   }    toggleExpand(id: any) {     this.onCellChange(id, '__expanded', false);     this.setState(prevState => ({       expandedColumns: {         ...prevState.expandedColumns,         [id]: !prevState.expandedColumns[id],       },     }));   }    sortColumn(col: string, sort = SortOrder.unsort) {     const { sortColumns } = this.props;     // default sort logic sorting string, boolean and number     const compareSort = (m: Sort, n: Sort) => {       if (typeof m === 'string') {         return (m || ' ').localeCompare(n);       }       return m - n;     };     return () => {       if (sortColumns?.includes(col)) {         // display in unsorted order if no sort specified         if (sort === SortOrder.unsort) {           const { collection } = createKeyedCollection(this.props.collection);           const collectionArray = createCollectionArray(collection);           this.setState({             collectionArray,             sortColumn: '',             sort,           });           return;         }          // newly ordered collection         const sorted = [...this.state.collectionArray].sort(           (a: object, b: object) => compareSort(a[col], b[col]),         );         const newCollection =           sort === SortOrder.asc ? sorted : sorted.reverse();          this.setState(prevState => ({           ...prevState,           collectionArray: newCollection,           sortColumn: col,           sort,         }));       }     };   }    renderSortIcon(col: string) {     if (this.state.sortColumn === col && this.state.sort === SortOrder.asc) {       return <Icons.SortAsc onClick={this.sortColumn(col, 2)} />;     }     if (this.state.sortColumn === col && this.state.sort === SortOrder.desc) {       return <Icons.SortDesc onClick={this.sortColumn(col, 0)} />;     }     return <Icons.Sort onClick={this.sortColumn(col, 1)} />;   }    renderHeaderRow() {     const cols = this.effectiveTableColumns();     const { allowDeletes, expandFieldset, extraButtons, sortColumns } =       this.props;     return (       <thead>         <tr>           {expandFieldset && <th aria-label=""Expand"" className=""tiny-cell"" />}           {cols.map(col => (             <th key={col}>               {this.getLabel(col)}               {sortColumns?.includes(col) && this.renderSortIcon(col)}             </th>           ))}           {extraButtons}           {allowDeletes && (             <th key=""delete-item"" aria-label=""Delete"" className=""tiny-cell"" />           )}         </tr>       </thead>     );   }    renderExpandableSection(item: any) {     const propsGenerator = () => ({ item, onChange: this.onFieldsetChange });     return recurseReactClone(       this.props.expandFieldset,       Fieldset,       propsGenerator,     );   }    getCellProps(record: any, col: any) {     const cellPropsFn = this.props.itemCellProps?.[col];     const val = record[col];     return cellPropsFn ? cellPropsFn(val, this.getLabel(col), record) : {};   }    renderCell(record: any, col: any) {     const renderer = this.props.itemRenderers?.[col];     const val = record[col];     const onChange = this.onCellChange.bind(this, record.id, col);     return renderer ? renderer(val, onChange, this.getLabel(col), record) : val;   }    renderItem(record: any) {     const { allowAddItem, allowDeletes, expandFieldset, tableColumns } =       this.props;     /* eslint-disable no-underscore-dangle */     const isExpanded =       !!this.state.expandedColumns[record.id] || record.__expanded;     let tds = [];     if (expandFieldset) {       tds.push(         <td key=""__expand"" className=""expand"">           <i             role=""button""             aria-label=""Toggle expand""             tabIndex={0}             className={`fa fa-caret-${               isExpanded ? 'down' : 'right'             } text-primary pointer`}             onClick={this.toggleExpand.bind(this, record.id)}           />         </td>,       );     }     tds = tds.concat(       tableColumns.map(col => (         <td {...this.getCellProps(record, col)} key={col}>           {this.renderCell(record, col)}         </td>       )),     );     if (allowAddItem) {       tds.push(<td key=""add"" />);     }     if (allowDeletes) {       tds.push(         <td           key=""__actions""           data-test=""crud-delete-option""           className=""text-primary""         >           <Icons.Trash             aria-label=""Delete item""             className=""pointer""             data-test=""crud-delete-icon""             role=""button""             tabIndex={0}             onClick={this.deleteItem.bind(this, record.id)}           />         </td>,       );     }     const trs = [       <tr {...{ 'data-test': 'table-row' }} className=""row"" key={record.id}>         {tds}       </tr>,     ];     if (isExpanded) {       trs.push(         <tr className=""exp"" key={`exp__${record.id}`}>           <td             colSpan={this.effectiveTableColumns().length}             className=""expanded""           >             <div>{this.renderExpandableSection(record)}</div>           </td>         </tr>,       );     }     return trs;   }    renderEmptyCell() {     return (       <tr>         <td className=""empty-collection"">{this.props.emptyMessage}</td>       </tr>     );   }    renderTableBody() {     const data = this.state.collectionArray;     const content = data.length       ? data.map(d => this.renderItem(d))       : this.renderEmptyCell();     return <tbody data-test=""table-content-rows"">{content}</tbody>;   }    render() {     return (       <>         <CrudButtonWrapper>           {this.props.allowAddItem && (             <StyledButtonWrapper>               <Button                 buttonSize=""small""                 buttonStyle=""tertiary""                 onClick={this.onAddItem}                 data-test=""add-item-button""               >                 <i data-test=""crud-add-table-item"" className=""fa fa-plus"" />{' '}                 {t('Add item')}               </Button>             </StyledButtonWrapper>           )}         </CrudButtonWrapper>         <CrudTableWrapper           className=""CRUD""           stickyHeader={this.props.stickyHeader}         >           <table data-test=""crud-table"" className=""table"">             {this.renderHeaderRow()}             {this.renderTableBody()}           </table>         </CrudTableWrapper>       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_23_152.js
as_24_157,Inefficient Rendering,"class DatasourceEditor extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       datasource: {         ...props.datasource,         owners: props.datasource.owners.map(owner => ({           value: owner.value || owner.id,           label: owner.label || `${owner.first_name} ${owner.last_name}`,         })),         metrics: props.datasource.metrics?.map(metric => {           const {             certified_by: certifiedByMetric,             certification_details: certificationDetails,           } = metric;           const {             certification: { details, certified_by: certifiedBy } = {},             warning_markdown: warningMarkdown,           } = JSON.parse(metric.extra || '{}') || {};           return {             ...metric,             certification_details: certificationDetails || details,             warning_markdown: warningMarkdown || '',             certified_by: certifiedBy || certifiedByMetric,           };         }),       },       errors: [],       isSqla:         props.datasource.datasource_type === 'table' ||         props.datasource.type === 'table',       isEditMode: false,       databaseColumns: props.datasource.columns.filter(col => !col.expression),       calculatedColumns: props.datasource.columns.filter(         col => !!col.expression,       ),       metadataLoading: false,       activeTabKey: 0,       datasourceType: props.datasource.sql         ? DATASOURCE_TYPES.virtual.key         : DATASOURCE_TYPES.physical.key,     };      this.onChange = this.onChange.bind(this);     this.onChangeEditMode = this.onChangeEditMode.bind(this);     this.onDatasourcePropChange = this.onDatasourcePropChange.bind(this);     this.onDatasourceChange = this.onDatasourceChange.bind(this);     this.tableChangeAndSyncMetadata =       this.tableChangeAndSyncMetadata.bind(this);     this.syncMetadata = this.syncMetadata.bind(this);     this.setColumns = this.setColumns.bind(this);     this.validateAndChange = this.validateAndChange.bind(this);     this.handleTabSelect = this.handleTabSelect.bind(this);     this.allowEditSource = !isFeatureEnabled(       FeatureFlag.DISABLE_DATASET_SOURCE_EDIT,     );   }    onChange() {     // Emptying SQL if ""Physical"" radio button is selected     // Currently the logic to know whether the source is     // physical or virtual is based on whether SQL is empty or not.     const { datasourceType, datasource } = this.state;     const sql =       datasourceType === DATASOURCE_TYPES.physical.key ? '' : datasource.sql;     const newDatasource = {       ...this.state.datasource,       sql,       columns: [...this.state.databaseColumns, ...this.state.calculatedColumns],     };     this.props.onChange(newDatasource, this.state.errors);   }    onChangeEditMode() {     this.props.setIsEditing(!this.state.isEditMode);     this.setState(prevState => ({ isEditMode: !prevState.isEditMode }));   }    onDatasourceChange(datasource, callback = this.validateAndChange) {     this.setState({ datasource }, callback);   }    onDatasourcePropChange(attr, value) {     if (value === undefined) return; // if value is undefined do not update state     const datasource = { ...this.state.datasource, [attr]: value };     this.setState(       prevState => ({         datasource: { ...prevState.datasource, [attr]: value },       }),       attr === 'table_name'         ? this.onDatasourceChange(datasource, this.tableChangeAndSyncMetadata)         : this.onDatasourceChange(datasource, this.validateAndChange),     );   }    onDatasourceTypeChange(datasourceType) {     this.setState({ datasourceType });   }    setColumns(obj) {     // update calculatedColumns or databaseColumns     this.setState(obj, this.validateAndChange);   }    validateAndChange() {     this.validate(this.onChange);   }    tableChangeAndSyncMetadata() {     this.validate(() => {       this.syncMetadata();       this.onChange();     });   }    updateColumns(cols) {     const { databaseColumns } = this.state;     const databaseColumnNames = cols.map(col => col.name);     const currentCols = databaseColumns.reduce(       (agg, col) => ({         ...agg,         [col.column_name]: col,       }),       {},     );     const finalColumns = [];     const results = {       added: [],       modified: [],       removed: databaseColumns         .map(col => col.column_name)         .filter(col => !databaseColumnNames.includes(col)),     };     cols.forEach(col => {       const currentCol = currentCols[col.name];       if (!currentCol) {         // new column         finalColumns.push({           id: shortid.generate(),           column_name: col.name,           type: col.type,           groupby: true,           filterable: true,           is_dttm: col.is_dttm,         });         results.added.push(col.name);       } else if (         currentCol.type !== col.type ||         (!currentCol.is_dttm && col.is_dttm)       ) {         // modified column         finalColumns.push({           ...currentCol,           type: col.type,           is_dttm: currentCol.is_dttm || col.is_dttm,         });         results.modified.push(col.name);       } else {         // unchanged         finalColumns.push(currentCol);       }     });     if (       results.added.length ||       results.modified.length ||       results.removed.length     ) {       this.setColumns({ databaseColumns: finalColumns });     }     return results;   }    syncMetadata() {     const { datasource } = this.state;     const params = {       datasource_type: datasource.type || datasource.datasource_type,       database_name:         datasource.database.database_name || datasource.database.name,       schema_name: datasource.schema,       table_name: datasource.table_name         ? encodeURIComponent(datasource.table_name)         : datasource.table_name,     };     Object.entries(params).forEach(([key, value]) => {       // rison can't encode the undefined value       if (value === undefined) {         params[key] = null;       }     });     const endpoint = `/datasource/external_metadata_by_name/?q=${rison.encode(       params,     )}`;     this.setState({ metadataLoading: true });      SupersetClient.get({ endpoint })       .then(({ json }) => {         const results = this.updateColumns(json);         if (results.modified.length) {           this.props.addSuccessToast(             t('Modified columns: %s', results.modified.join(', ')),           );         }         if (results.removed.length) {           this.props.addSuccessToast(             t('Removed columns: %s', results.removed.join(', ')),           );         }         if (results.added.length) {           this.props.addSuccessToast(             t('New columns added: %s', results.added.join(', ')),           );         }         this.props.addSuccessToast(t('Metadata has been synced'));         this.setState({ metadataLoading: false });       })       .catch(response =>         getClientErrorObject(response).then(({ error, statusText }) => {           this.props.addDangerToast(             error || statusText || t('An error has occurred'),           );           this.setState({ metadataLoading: false });         }),       );   }    findDuplicates(arr, accessor) {     const seen = {};     const dups = [];     arr.forEach(obj => {       const item = accessor(obj);       if (item in seen) {         dups.push(item);       } else {         seen[item] = null;       }     });     return dups;   }    validate(callback) {     let errors = [];     let dups;     const { datasource } = this.state;      // Looking for duplicate column_name     dups = this.findDuplicates(datasource.columns, obj => obj.column_name);     errors = errors.concat(       dups.map(name => t('Column name [%s] is duplicated', name)),     );      // Looking for duplicate metric_name     dups = this.findDuplicates(datasource.metrics, obj => obj.metric_name);     errors = errors.concat(       dups.map(name => t('Metric name [%s] is duplicated', name)),     );      // Making sure calculatedColumns have an expression defined     const noFilterCalcCols = this.state.calculatedColumns.filter(       col => !col.expression && !col.json,     );     errors = errors.concat(       noFilterCalcCols.map(col =>         t('Calculated column [%s] requires an expression', col.column_name),       ),     );      this.setState({ errors }, callback);   }    handleTabSelect(activeTabKey) {     this.setState({ activeTabKey });   }    sortMetrics(metrics) {     return metrics.sort(({ id: a }, { id: b }) => b - a);   }    renderSettingsFieldset() {     const { datasource } = this.state;     return (       <Fieldset         title={t('Basic')}         item={datasource}         onChange={this.onDatasourceChange}       >         <Field           fieldKey=""description""           label={t('Description')}           control={             <TextAreaControl               language=""markdown""               offerEditInModal={false}               resize=""vertical""             />           }         />         <Field           fieldKey=""default_endpoint""           label={t('Default URL')}           description={t(             'Default URL to redirect to when accessing from the dataset list page',           )}           control={<TextControl controlId=""default_endpoint"" />}         />         <Field           inline           fieldKey=""filter_select_enabled""           label={t('Autocomplete filters')}           description={t('Whether to populate autocomplete filters options')}           control={<CheckboxControl />}         />         {this.state.isSqla && (           <Field             fieldKey=""fetch_values_predicate""             label={t('Autocomplete query predicate')}             description={t(               'When using ""Autocomplete filters"", this can be used to improve performance ' +                 'of the query fetching the values. Use this option to apply a ' +                 'predicate (WHERE clause) to the query selecting the distinct ' +                 'values from the table. Typically the intent would be to limit the scan ' +                 'by applying a relative time filter on a partitioned or indexed time-related field.',             )}             control={               <TextAreaControl                 language=""sql""                 controlId=""fetch_values_predicate""                 minLines={5}                 resize=""vertical""               />             }           />         )}         {this.state.isSqla && (           <Field             fieldKey=""extra""             label={t('Extra')}             description={t(               'Extra data to specify table metadata. Currently supports ' +                 'metadata of the format: `{ ""certification"": { ""certified_by"": ' +                 '""Data Platform Team"", ""details"": ""This table is the source of truth."" ' +                 '}, ""warning_markdown"": ""This is a warning."" }`.',             )}             control={               <TextAreaControl                 controlId=""extra""                 language=""json""                 offerEditInModal={false}                 resize=""vertical""               />             }           />         )}         <OwnersSelector           datasource={datasource}           onChange={newOwners => {             this.onDatasourceChange({ ...datasource, owners: newOwners });           }}         />       </Fieldset>     );   }    renderAdvancedFieldset() {     const { datasource } = this.state;     return (       <Fieldset         title={t('Advanced')}         item={datasource}         onChange={this.onDatasourceChange}       >         <Field           fieldKey=""cache_timeout""           label={t('Cache timeout')}           description={t(             'The duration of time in seconds before the cache is invalidated. Set to -1 to bypass the cache.',           )}           control={<TextControl controlId=""cache_timeout"" />}         />         <Field           fieldKey=""offset""           label={t('Hours offset')}           control={<TextControl controlId=""offset"" />}           description={t(             'The number of hours, negative or positive, to shift the time column. This can be used to move UTC time to local time.',           )}         />         {this.state.isSqla && (           <Field             fieldKey=""template_params""             label={t('Template parameters')}             description={t(               'A set of parameters that become available in the query using Jinja templating syntax',             )}             control={<TextControl controlId=""template_params"" />}           />         )}       </Fieldset>     );   }    renderSpatialTab() {     const { datasource } = this.state;     const { spatials, all_cols: allCols } = datasource;     return (       <Tabs.TabPane         tab={<CollectionTabTitle collection={spatials} title={t('Spatial')} />}         key={4}       >         <CollectionTable           tableColumns={['name', 'config']}           onChange={this.onDatasourcePropChange.bind(this, 'spatials')}           itemGenerator={() => ({             name: t('<new spatial>'),             type: t('<no type>'),             config: null,           })}           collection={spatials}           allowDeletes           itemRenderers={{             name: (d, onChange) => (               <EditableTitle canEdit title={d} onSaveTitle={onChange} />             ),             config: (v, onChange) => (               <SpatialControl value={v} onChange={onChange} choices={allCols} />             ),           }}         />       </Tabs.TabPane>     );   }    renderSourceFieldset(theme) {     const { datasource } = this.state;     return (       <div>         {this.allowEditSource && (           <EditLockContainer>             <span role=""button"" tabIndex={0} onClick={this.onChangeEditMode}>               {this.state.isEditMode ? (                 <Icons.LockUnlocked iconColor={theme.colors.grayscale.base} />               ) : (                 <Icons.LockLocked iconColor={theme.colors.grayscale.base} />               )}             </span>             {!this.state.isEditMode && (               <div>{t('Click the lock to make changes.')}</div>             )}             {this.state.isEditMode && (               <div>{t('Click the lock to prevent further changes.')}</div>             )}           </EditLockContainer>         )}         <div className=""m-l-10 m-t-20 m-b-10"">           {DATASOURCE_TYPES_ARR.map(type => (             <Radio               key={type.key}               value={type.key}               inline               onChange={this.onDatasourceTypeChange.bind(this, type.key)}               checked={this.state.datasourceType === type.key}               disabled={!this.state.isEditMode}             >               {type.label}             </Radio>           ))}         </div>         <hr />         <Fieldset item={datasource} onChange={this.onDatasourceChange} compact>           {this.state.datasourceType === DATASOURCE_TYPES.virtual.key && (             <div>               {this.state.isSqla && (                 <>                   <Col xs={24} md={12}>                     <Field                       fieldKey=""databaseSelector""                       label={t('virtual')}                       control={                         <div css={{ marginTop: 8 }}>                           <DatabaseSelector                             db={datasource?.database}                             schema={datasource.schema}                             onSchemaChange={schema =>                               this.state.isEditMode &&                               this.onDatasourcePropChange('schema', schema)                             }                             onDbChange={database =>                               this.state.isEditMode &&                               this.onDatasourcePropChange('database', database)                             }                             formMode={false}                             handleError={this.props.addDangerToast}                             readOnly={!this.state.isEditMode}                           />                         </div>                       }                     />                     <div css={{ width: 'calc(100% - 34px)', marginTop: -16 }}>                       <Field                         fieldKey=""table_name""                         label={t('Dataset name')}                         control={                           <TextControl                             controlId=""table_name""                             onChange={table => {                               this.onDatasourcePropChange('table_name', table);                             }}                             placeholder={t('Dataset name')}                             disabled={!this.state.isEditMode}                           />                         }                       />                     </div>                   </Col>                   <Field                     fieldKey=""sql""                     label={t('SQL')}                     description={t(                       'When specifying SQL, the datasource acts as a view. ' +                         'Superset will use this statement as a subquery while grouping and filtering ' +                         'on the generated parent queries.',                     )}                     control={                       <TextAreaControl                         language=""sql""                         offerEditInModal={false}                         minLines={20}                         maxLines={20}                         readOnly={!this.state.isEditMode}                         resize=""both""                       />                     }                   />                 </>               )}             </div>           )}           {this.state.datasourceType === DATASOURCE_TYPES.physical.key && (             <Col xs={24} md={12}>               {this.state.isSqla && (                 <Field                   fieldKey=""tableSelector""                   label={t('Physical')}                   control={                     <div css={{ marginTop: 8 }}>                       <TableSelector                         clearable={false}                         database={{                           ...datasource.database,                           database_name:                             datasource.database?.database_name ||                             datasource.database?.name,                         }}                         dbId={datasource.database?.id}                         handleError={this.props.addDangerToast}                         schema={datasource.schema}                         sqlLabMode={false}                         tableValue={datasource.table_name}                         onSchemaChange={                           this.state.isEditMode                             ? schema =>                                 this.onDatasourcePropChange('schema', schema)                             : undefined                         }                         onDbChange={                           this.state.isEditMode                             ? database =>                                 this.onDatasourcePropChange(                                   'database',                                   database,                                 )                             : undefined                         }                         onTableSelectChange={                           this.state.isEditMode                             ? table =>                                 this.onDatasourcePropChange('table_name', table)                             : undefined                         }                         readOnly={!this.state.isEditMode}                       />                     </div>                   }                   description={t(                     'The pointer to a physical table (or view). Keep in mind that the chart is ' +                       'associated to this Superset logical table, and this logical table points ' +                       'the physical table referenced here.',                   )}                 />               )}             </Col>           )}         </Fieldset>       </div>     );   }    renderErrors() {     if (this.state.errors.length > 0) {       return (         <Alert           css={theme => ({ marginBottom: theme.gridUnit * 4 })}           type=""error""           message={             <>               {this.state.errors.map(err => (                 <div key={err}>{err}</div>               ))}             </>           }         />       );     }     return null;   }    renderMetricCollection() {     const { datasource } = this.state;     const { metrics } = datasource;     const sortedMetrics = metrics?.length ? this.sortMetrics(metrics) : [];     return (       <CollectionTable         tableColumns={['metric_name', 'verbose_name', 'expression']}         sortColumns={['metric_name', 'verbose_name', 'expression']}         columnLabels={{           metric_name: t('Metric'),           verbose_name: t('Label'),           expression: t('SQL expression'),         }}         expandFieldset={           <FormContainer>             <Fieldset compact>               <Field                 fieldKey=""description""                 label={t('Description')}                 control={                   <TextControl                     controlId=""description""                     placeholder={t('Description')}                   />                 }               />               <Field                 fieldKey=""d3format""                 label={t('D3 format')}                 control={                   <TextControl controlId=""d3format"" placeholder=""%y/%m/%d"" />                 }               />               <Field                 label={t('Certified by')}                 fieldKey=""certified_by""                 description={t(                   'Person or group that has certified this metric',                 )}                 control={                   <TextControl                     controlId=""certified_by""                     placeholder={t('Certified by')}                   />                 }               />               <Field                 label={t('Certification details')}                 fieldKey=""certification_details""                 description={t('Details of the certification')}                 control={                   <TextControl                     controlId=""certification_details""                     placeholder={t('Certification details')}                   />                 }               />               <Field                 label={t('Warning')}                 fieldKey=""warning_markdown""                 description={t('Optional warning about use of this metric')}                 control={                   <TextAreaControl                     controlId=""warning_markdown""                     language=""markdown""                     offerEditInModal={false}                     resize=""vertical""                   />                 }               />             </Fieldset>           </FormContainer>         }         collection={sortedMetrics}         allowAddItem         onChange={this.onDatasourcePropChange.bind(this, 'metrics')}         itemGenerator={() => ({           metric_name: t('<new metric>'),           verbose_name: '',           expression: '',         })}         itemCellProps={{           expression: () => ({             width: '240px',           }),         }}         itemRenderers={{           metric_name: (v, onChange, _, record) => (             <FlexRowContainer>               {record.is_certified && (                 <CertifiedBadge                   certifiedBy={record.certified_by}                   details={record.certification_details}                 />               )}               {record.warning_markdown && (                 <WarningIconWithTooltip                   warningMarkdown={record.warning_markdown}                 />               )}               <EditableTitle canEdit title={v} onSaveTitle={onChange} />             </FlexRowContainer>           ),           verbose_name: (v, onChange) => (             <TextControl canEdit value={v} onChange={onChange} />           ),           expression: (v, onChange) => (             <TextAreaControl               canEdit               initialValue={v}               onChange={onChange}               extraClasses={['datasource-sql-expression']}               language=""sql""               offerEditInModal={false}               minLines={5}               textAreaStyles={{ minWidth: '200px', maxWidth: '450px' }}               resize=""both""             />           ),           description: (v, onChange, label) => (             <StackedField               label={label}               formElement={<TextControl value={v} onChange={onChange} />}             />           ),           d3format: (v, onChange, label) => (             <StackedField               label={label}               formElement={<TextControl value={v} onChange={onChange} />}             />           ),         }}         allowDeletes         stickyHeader       />     );   }    render() {     const { datasource, activeTabKey } = this.state;     const { metrics } = datasource;     const sortedMetrics = metrics?.length ? this.sortMetrics(metrics) : [];     const { theme } = this.props;      return (       <DatasourceContainer>         {this.renderErrors()}         <Alert           css={theme => ({ marginBottom: theme.gridUnit * 4 })}           type=""warning""           message={             <>               {' '}               <strong>{t('Be careful.')} </strong>               {t(                 'Changing these settings will affect all charts using this dataset, including charts owned by other people.',               )}             </>           }         />         <StyledTableTabs           fullWidth={false}           id=""table-tabs""           data-test=""edit-dataset-tabs""           onChange={this.handleTabSelect}           defaultActiveKey={activeTabKey}         >           <Tabs.TabPane key={0} tab={t('Source')}>             {this.renderSourceFieldset(theme)}           </Tabs.TabPane>           <Tabs.TabPane             tab={               <CollectionTabTitle                 collection={sortedMetrics}                 title={t('Metrics')}               />             }             key={1}           >             {this.renderMetricCollection()}           </Tabs.TabPane>           <Tabs.TabPane             tab={               <CollectionTabTitle                 collection={this.state.databaseColumns}                 title={t('Columns')}               />             }             key={2}           >             <StyledColumnsTabWrapper>               <ColumnButtonWrapper>                 <StyledButtonWrapper>                   <Button                     buttonSize=""small""                     buttonStyle=""tertiary""                     onClick={this.syncMetadata}                     className=""sync-from-source""                     disabled={this.state.isEditMode}                   >                     <i className=""fa fa-database"" />{' '}                     {t('Sync columns from source')}                   </Button>                 </StyledButtonWrapper>               </ColumnButtonWrapper>               <ColumnCollectionTable                 className=""columns-table""                 columns={this.state.databaseColumns}                 datasource={datasource}                 onColumnsChange={databaseColumns =>                   this.setColumns({ databaseColumns })                 }                 onDatasourceChange={this.onDatasourceChange}               />               {this.state.metadataLoading && <Loading />}             </StyledColumnsTabWrapper>           </Tabs.TabPane>           <Tabs.TabPane             tab={               <CollectionTabTitle                 collection={this.state.calculatedColumns}                 title={t('Calculated columns')}               />             }             key={3}           >             <StyledColumnsTabWrapper>               <ColumnCollectionTable                 columns={this.state.calculatedColumns}                 onColumnsChange={calculatedColumns =>                   this.setColumns({ calculatedColumns })                 }                 onDatasourceChange={this.onDatasourceChange}                 datasource={datasource}                 editableColumnName                 showExpression                 allowAddItem                 allowEditDataType                 itemGenerator={() => ({                   column_name: t('<new column>'),                   filterable: true,                   groupby: true,                   expression: t('<enter SQL expression here>'),                   __expanded: true,                 })}               />             </StyledColumnsTabWrapper>           </Tabs.TabPane>           <Tabs.TabPane key={4} tab={t('Settings')}>             <Row gutter={16}>               <Col xs={24} md={12}>                 <FormContainer>{this.renderSettingsFieldset()}</FormContainer>               </Col>               <Col xs={24} md={12}>                 <FormContainer>{this.renderAdvancedFieldset()}</FormContainer>               </Col>             </Row>           </Tabs.TabPane>         </StyledTableTabs>       </DatasourceContainer>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_24_157.js
as_25_197,Inefficient Rendering,"export default function AnchorLink({   id,   dashboardId,   placement = 'right',   scrollIntoView = false,   showShortLinkButton = true, }: AnchorLinkProps) {   const scrollAnchorIntoView = (elementId: string) => {     const element = document.getElementById(elementId);     if (element) {       element.scrollIntoView({         block: 'center',         behavior: 'smooth',       });     }   };    // will always scroll element into view if element id and url hash match   const hash = getLocationHash();   useEffect(() => {     if (hash && id === hash) {       scrollAnchorIntoView(id);     }   }, [hash, id]);    // force scroll into view   useEffect(() => {     if (scrollIntoView) {       scrollAnchorIntoView(id);     }   }, [id, scrollIntoView]);    return (     <span className=""anchor-link-container"" id={id}>       {showShortLinkButton && dashboardId && (         <URLShortLinkButton           anchorLinkId={id}           dashboardId={dashboardId}           emailSubject={t('Superset chart')}           emailContent={t('Check out this chart in dashboard:')}           placement={placement}         />       )}     </span>   ); }",C:\Users\Owner\Desktop\DatasetFiles\as_25_197.js
as_26_198,Inefficient Rendering,"class CssEditor extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       css: props.initialCss,     };     this.changeCss = this.changeCss.bind(this);     this.changeCssTemplate = this.changeCssTemplate.bind(this);   }    componentDidMount() {     AceCssEditor.preload();   }    changeCss(css) {     this.setState({ css }, () => {       this.props.onChange(css);     });   }    changeCssTemplate({ key }) {     this.changeCss(key);   }    renderTemplateSelector() {     if (this.props.templates) {       const menu = (         <Menu onClick={this.changeCssTemplate}>           {this.props.templates.map(template => (             <Menu.Item key={template.css}>{template.label}</Menu.Item>           ))}         </Menu>       );        return (         <AntdDropdown overlay={menu} placement=""bottomRight"">           <Button>{t('Load a CSS template')}</Button>         </AntdDropdown>       );     }     return null;   }    render() {     return (       <ModalTrigger         triggerNode={this.props.triggerNode}         modalTitle={t('CSS')}         modalBody={           <StyledWrapper>             <div className=""css-editor-header"">               <h5>{t('Live CSS editor')}</h5>               {this.renderTemplateSelector()}             </div>             <AceCssEditor               className=""css-editor""               minLines={12}               maxLines={30}               onChange={this.changeCss}               height=""200px""               width=""100%""               editorProps={{ $blockScrolling: true }}               enableLiveAutocompletion               value={this.state.css || ''}             />           </StyledWrapper>         }       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_26_198.js
as_27_199,Props in initial state,"class CssEditor extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       css: props.initialCss,     };     this.changeCss = this.changeCss.bind(this);     this.changeCssTemplate = this.changeCssTemplate.bind(this);   }    componentDidMount() {     AceCssEditor.preload();   }    changeCss(css) {     this.setState({ css }, () => {       this.props.onChange(css);     });   }    changeCssTemplate({ key }) {     this.changeCss(key);   }    renderTemplateSelector() {     if (this.props.templates) {       const menu = (         <Menu onClick={this.changeCssTemplate}>           {this.props.templates.map(template => (             <Menu.Item key={template.css}>{template.label}</Menu.Item>           ))}         </Menu>       );        return (         <AntdDropdown overlay={menu} placement=""bottomRight"">           <Button>{t('Load a CSS template')}</Button>         </AntdDropdown>       );     }     return null;   }    render() {     return (       <ModalTrigger         triggerNode={this.props.triggerNode}         modalTitle={t('CSS')}         modalBody={           <StyledWrapper>             <div className=""css-editor-header"">               <h5>{t('Live CSS editor')}</h5>               {this.renderTemplateSelector()}             </div>             <AceCssEditor               className=""css-editor""               minLines={12}               maxLines={30}               onChange={this.changeCss}               height=""200px""               width=""100%""               editorProps={{ $blockScrolling: true }}               enableLiveAutocompletion               value={this.state.css || ''}             />           </StyledWrapper>         }       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_27_199.js
as_28_202,Inefficient Rendering,"class Dashboard extends React.PureComponent {   static contextType = PluginContext;    static onBeforeUnload(hasChanged) {     if (hasChanged) {       window.addEventListener('beforeunload', Dashboard.unload);     } else {       window.removeEventListener('beforeunload', Dashboard.unload);     }   }    static unload() {     const message = t('You have unsaved changes.');     window.event.returnValue = message; // Gecko + IE     return message; // Gecko + Webkit, Safari, Chrome etc.   }    constructor(props) {     super(props);     this.appliedFilters = props.activeFilters ?? {};     this.appliedOwnDataCharts = props.ownDataCharts ?? {};     this.onVisibilityChange = this.onVisibilityChange.bind(this);   }    componentDidMount() {     const bootstrapData = getBootstrapData();     const { dashboardState, layout } = this.props;     const eventData = {       is_soft_navigation: Logger.timeOriginOffset > 0,       is_edit_mode: dashboardState.editMode,       mount_duration: Logger.getTimestamp(),       is_empty: isDashboardEmpty(layout),       is_published: dashboardState.isPublished,       bootstrap_data_length: bootstrapData.length,     };     const directLinkComponentId = getLocationHash();     if (directLinkComponentId) {       eventData.target_id = directLinkComponentId;     }     this.props.actions.logEvent(LOG_ACTIONS_MOUNT_DASHBOARD, eventData);      // Handle browser tab visibility change     if (document.visibilityState === 'hidden') {       this.visibilityEventData = {         start_offset: Logger.getTimestamp(),         ts: new Date().getTime(),       };     }     window.addEventListener('visibilitychange', this.onVisibilityChange);     this.applyCharts();   }    componentDidUpdate() {     this.applyCharts();   }    UNSAFE_componentWillReceiveProps(nextProps) {     const currentChartIds = getChartIdsFromLayout(this.props.layout);     const nextChartIds = getChartIdsFromLayout(nextProps.layout);      if (this.props.dashboardInfo.id !== nextProps.dashboardInfo.id) {       // single-page-app navigation check       return;     }      if (currentChartIds.length < nextChartIds.length) {       const newChartIds = nextChartIds.filter(         key => currentChartIds.indexOf(key) === -1,       );       newChartIds.forEach(newChartId =>         this.props.actions.addSliceToDashboard(           newChartId,           getLayoutComponentFromChartId(nextProps.layout, newChartId),         ),       );     } else if (currentChartIds.length > nextChartIds.length) {       // remove chart       const removedChartIds = currentChartIds.filter(         key => nextChartIds.indexOf(key) === -1,       );       removedChartIds.forEach(removedChartId =>         this.props.actions.removeSliceFromDashboard(removedChartId),       );     }   }    applyCharts() {     const { hasUnsavedChanges, editMode } = this.props.dashboardState;      const { appliedFilters, appliedOwnDataCharts } = this;     const { activeFilters, ownDataCharts, chartConfiguration } = this.props;     if (       isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS) &&       !chartConfiguration     ) {       // For a first loading we need to wait for cross filters charts data loaded to get all active filters       // for correct comparing  of filters to avoid unnecessary requests       return;     }      if (       !editMode &&       (!areObjectsEqual(appliedOwnDataCharts, ownDataCharts, {         ignoreUndefined: true,       }) ||         !areObjectsEqual(appliedFilters, activeFilters, {           ignoreUndefined: true,         }))     ) {       this.applyFilters();     }      if (hasUnsavedChanges) {       Dashboard.onBeforeUnload(true);     } else {       Dashboard.onBeforeUnload(false);     }   }    componentWillUnmount() {     window.removeEventListener('visibilitychange', this.onVisibilityChange);     this.props.actions.clearDataMaskState();   }    onVisibilityChange() {     if (document.visibilityState === 'hidden') {       // from visible to hidden       this.visibilityEventData = {         start_offset: Logger.getTimestamp(),         ts: new Date().getTime(),       };     } else if (document.visibilityState === 'visible') {       // from hidden to visible       const logStart = this.visibilityEventData.start_offset;       this.props.actions.logEvent(LOG_ACTIONS_HIDE_BROWSER_TAB, {         ...this.visibilityEventData,         duration: Logger.getTimestamp() - logStart,       });     }   }    // return charts in array   getAllCharts() {     return Object.values(this.props.charts);   }    applyFilters() {     const { appliedFilters } = this;     const { activeFilters, ownDataCharts } = this.props;      // refresh charts if a filter was removed, added, or changed     const currFilterKeys = Object.keys(activeFilters);     const appliedFilterKeys = Object.keys(appliedFilters);      const allKeys = new Set(currFilterKeys.concat(appliedFilterKeys));     const affectedChartIds = getAffectedOwnDataCharts(       ownDataCharts,       this.appliedOwnDataCharts,     );     [...allKeys].forEach(filterKey => {       if (         !currFilterKeys.includes(filterKey) &&         appliedFilterKeys.includes(filterKey)       ) {         // filterKey is removed?         affectedChartIds.push(...appliedFilters[filterKey].scope);       } else if (!appliedFilterKeys.includes(filterKey)) {         // filterKey is newly added?         affectedChartIds.push(...activeFilters[filterKey].scope);       } else {         // if filterKey changes value,         // update charts in its scope         if (           !areObjectsEqual(             appliedFilters[filterKey].values,             activeFilters[filterKey].values,             {               ignoreUndefined: true,             },           )         ) {           affectedChartIds.push(...activeFilters[filterKey].scope);         }          // if filterKey changes scope,         // update all charts in its scope         if (           !areObjectsEqual(             appliedFilters[filterKey].scope,             activeFilters[filterKey].scope,           )         ) {           const chartsInScope = (activeFilters[filterKey].scope || []).concat(             appliedFilters[filterKey].scope || [],           );           affectedChartIds.push(...chartsInScope);         }       }     });      // remove dup in affectedChartIds     this.refreshCharts([...new Set(affectedChartIds)]);     this.appliedFilters = activeFilters;     this.appliedOwnDataCharts = ownDataCharts;   }    refreshCharts(ids) {     ids.forEach(id => {       this.props.actions.triggerQuery(true, id);     });   }    render() {     if (this.context.loading) {       return <Loading />;     }     return (       <>         <DashboardBuilder />       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_28_202.js
as_29_209,Inefficient Rendering,"class DashboardGrid extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       isResizing: false,     };      this.handleResizeStart = this.handleResizeStart.bind(this);     this.handleResizeStop = this.handleResizeStop.bind(this);     this.handleTopDropTargetDrop = this.handleTopDropTargetDrop.bind(this);     this.getRowGuidePosition = this.getRowGuidePosition.bind(this);     this.setGridRef = this.setGridRef.bind(this);     this.handleChangeTab = this.handleChangeTab.bind(this);   }    getRowGuidePosition(resizeRef) {     if (resizeRef && this.grid) {       return (         resizeRef.getBoundingClientRect().bottom -         this.grid.getBoundingClientRect().top -         2       );     }     return null;   }    setGridRef(ref) {     this.grid = ref;   }    handleResizeStart() {     this.setState(() => ({       isResizing: true,     }));   }    handleResizeStop({ id, widthMultiple: width, heightMultiple: height }) {     this.props.resizeComponent({ id, width, height });      this.setState(() => ({       isResizing: false,     }));   }    handleTopDropTargetDrop(dropResult) {     if (dropResult) {       this.props.handleComponentDrop({         ...dropResult,         destination: {           ...dropResult.destination,           // force appending as the first child if top drop target           index: 0,         },       });     }   }    handleChangeTab({ pathToTabIndex }) {     this.props.setDirectPathToChild(pathToTabIndex);   }    render() {     const {       gridComponent,       handleComponentDrop,       depth,       width,       isComponentVisible,       editMode,       canEdit,       setEditMode,       dashboardId,     } = this.props;     const columnPlusGutterWidth =       (width + GRID_GUTTER_SIZE) / GRID_COLUMN_COUNT;      const columnWidth = columnPlusGutterWidth - GRID_GUTTER_SIZE;     const { isResizing } = this.state;      const shouldDisplayEmptyState = gridComponent?.children?.length === 0;     const shouldDisplayTopLevelTabEmptyState =       shouldDisplayEmptyState && gridComponent.type === TAB_TYPE;      const dashboardEmptyState = editMode && (       <EmptyStateBig         title={t('Drag and drop components and charts to the dashboard')}         description={t(           'You can create a new chart or use existing ones from the panel on the right',         )}         buttonText={           <>             <i className=""fa fa-plus"" />             {t('Create a new chart')}           </>         }         buttonAction={() => {           window.open(             `/chart/add?dashboard_id=${dashboardId}`,             '_blank',             'noopener noreferrer',           );         }}         image=""chart.svg""       />     );      const topLevelTabEmptyState = editMode ? (       <EmptyStateBig         title={t('Drag and drop components to this tab')}         description={t(           `You can create a new chart or use existing ones from the panel on the right`,         )}         buttonText={           <>             <i className=""fa fa-plus"" />             {t('Create a new chart')}           </>         }         buttonAction={() => {           window.open(             `/chart/add?dashboard_id=${dashboardId}`,             '_blank',             'noopener noreferrer',           );         }}         image=""chart.svg""       />     ) : (       <EmptyStateBig         title={t('There are no components added to this tab')}         description={           canEdit && t('You can add the components in the edit mode.')         }         buttonText={canEdit && t('Edit the dashboard')}         buttonAction={           canEdit &&           (() => {             setEditMode(true);           })         }         image=""chart.svg""       />     );      return width < 100 ? null : (       <>         {shouldDisplayEmptyState && (           <DashboardEmptyStateContainer>             {shouldDisplayTopLevelTabEmptyState               ? topLevelTabEmptyState               : dashboardEmptyState}           </DashboardEmptyStateContainer>         )}         <div className=""dashboard-grid"" ref={this.setGridRef}>           <GridContent className=""grid-content"" data-test=""grid-content"">             {/* make the area above components droppable */}             {editMode && (               <DragDroppable                 component={gridComponent}                 depth={depth}                 parentComponent={null}                 index={0}                 orientation=""column""                 onDrop={this.handleTopDropTargetDrop}                 className=""empty-droptarget""                 editMode               >                 {renderDraggableContentBottom}               </DragDroppable>             )}             {gridComponent?.children?.map((id, index) => (               <DashboardComponent                 key={id}                 id={id}                 parentId={gridComponent.id}                 depth={depth + 1}                 index={index}                 availableColumnCount={GRID_COLUMN_COUNT}                 columnWidth={columnWidth}                 isComponentVisible={isComponentVisible}                 onResizeStart={this.handleResizeStart}                 onResize={this.handleResize}                 onResizeStop={this.handleResizeStop}                 onChangeTab={this.handleChangeTab}               />             ))}             {/* make the area below components droppable */}             {editMode && gridComponent?.children?.length > 0 && (               <DragDroppable                 component={gridComponent}                 depth={depth}                 parentComponent={null}                 index={gridComponent.children.length}                 orientation=""column""                 onDrop={handleComponentDrop}                 className=""empty-droptarget""                 editMode               >                 {renderDraggableContentTop}               </DragDroppable>             )}             {isResizing &&               Array(GRID_COLUMN_COUNT)                 .fill(null)                 .map((_, i) => (                   <GridColumnGuide                     key={`grid-column-${i}`}                     className=""grid-column-guide""                     style={{                       left: i * GRID_GUTTER_SIZE + i * columnWidth,                       width: columnWidth,                     }}                   />                 ))}           </GridContent>         </div>       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_29_209.js
as_30_214,Inefficient Rendering,"export default class FilterScopeSelector extends React.PureComponent {   constructor(props) {     super(props);      const { dashboardFilters, layout } = props;      if (Object.keys(dashboardFilters).length > 0) {       // display filter fields in tree structure       const filterFieldNodes = getFilterFieldNodesTree({         dashboardFilters,       });       // filterFieldNodes root node is dashboard_root component,       // so that we can offer a select/deselect all link       const filtersNodes = filterFieldNodes[0].children;       this.allfilterFields = [];       filtersNodes.forEach(({ children }) => {         children.forEach(child => {           this.allfilterFields.push(child.value);         });       });       this.defaultFilterKey = filtersNodes[0].children[0].value;        // build FilterScopeTree object for each filterKey       const filterScopeMap = Object.values(dashboardFilters).reduce(         (map, { chartId: filterId, columns }) => {           const filterScopeByChartId = Object.keys(columns).reduce(             (mapByChartId, columnName) => {               const filterKey = getDashboardFilterKey({                 chartId: filterId,                 column: columnName,               });               const nodes = getFilterScopeNodesTree({                 components: layout,                 filterFields: [filterKey],                 selectedChartId: filterId,               });               const expanded = getFilterScopeParentNodes(nodes, 1);               // force display filter_box chart as unchecked, but show checkbox as disabled               const chartIdsInFilterScope = (                 getChartIdsInFilterBoxScope({                   filterScope: dashboardFilters[filterId].scopes[columnName],                 }) || []               ).filter(id => id !== filterId);                return {                 ...mapByChartId,                 [filterKey]: {                   // unfiltered nodes                   nodes,                   // filtered nodes in display if searchText is not empty                   nodesFiltered: [...nodes],                   checked: chartIdsInFilterScope,                   expanded,                 },               };             },             {},           );            return {             ...map,             ...filterScopeByChartId,           };         },         {},       );        // initial state: active defaultFilerKey       const { chartId } = getChartIdAndColumnFromFilterKey(         this.defaultFilterKey,       );       const checkedFilterFields = [];       const activeFilterField = this.defaultFilterKey;       // expand defaultFilterKey in filter field tree       const expandedFilterIds = [ALL_FILTERS_ROOT].concat(chartId);        const filterScopeTreeEntry = buildFilterScopeTreeEntry({         checkedFilterFields,         activeFilterField,         filterScopeMap,         layout,       });       this.state = {         showSelector: true,         activeFilterField,         searchText: '',         filterScopeMap: {           ...filterScopeMap,           ...filterScopeTreeEntry,         },         filterFieldNodes,         checkedFilterFields,         expandedFilterIds,       };     } else {       this.state = {         showSelector: false,       };     }      this.filterNodes = this.filterNodes.bind(this);     this.onChangeFilterField = this.onChangeFilterField.bind(this);     this.onCheckFilterScope = this.onCheckFilterScope.bind(this);     this.onExpandFilterScope = this.onExpandFilterScope.bind(this);     this.onSearchInputChange = this.onSearchInputChange.bind(this);     this.onCheckFilterField = this.onCheckFilterField.bind(this);     this.onExpandFilterField = this.onExpandFilterField.bind(this);     this.onClose = this.onClose.bind(this);     this.onSave = this.onSave.bind(this);   }    onCheckFilterScope(checked = []) {     const { activeFilterField, filterScopeMap, checkedFilterFields } =       this.state;      const key = getKeyForFilterScopeTree({       activeFilterField,       checkedFilterFields,     });     const editingList = activeFilterField       ? [activeFilterField]       : checkedFilterFields;     const updatedEntry = {       ...filterScopeMap[key],       checked,     };      const updatedFilterScopeMap = getRevertedFilterScope({       checked,       filterFields: editingList,       filterScopeMap,     });      this.setState(() => ({       filterScopeMap: {         ...filterScopeMap,         ...updatedFilterScopeMap,         [key]: updatedEntry,       },     }));   }    onExpandFilterScope(expanded = []) {     const { activeFilterField, checkedFilterFields, filterScopeMap } =       this.state;     const key = getKeyForFilterScopeTree({       activeFilterField,       checkedFilterFields,     });     const updatedEntry = {       ...filterScopeMap[key],       expanded,     };     this.setState(() => ({       filterScopeMap: {         ...filterScopeMap,         [key]: updatedEntry,       },     }));   }    onCheckFilterField(checkedFilterFields = []) {     const { layout } = this.props;     const { filterScopeMap } = this.state;     const filterScopeTreeEntry = buildFilterScopeTreeEntry({       checkedFilterFields,       activeFilterField: null,       filterScopeMap,       layout,     });      this.setState(() => ({       activeFilterField: null,       checkedFilterFields,       filterScopeMap: {         ...filterScopeMap,         ...filterScopeTreeEntry,       },     }));   }    onExpandFilterField(expandedFilterIds = []) {     this.setState(() => ({       expandedFilterIds,     }));   }    onChangeFilterField(filterField = {}) {     const { layout } = this.props;     const nextActiveFilterField = filterField.value;     const {       activeFilterField: currentActiveFilterField,       checkedFilterFields,       filterScopeMap,     } = this.state;      // we allow single edit and multiple edit in the same view.     // if user click on the single filter field,     // will show filter scope for the single field.     // if user click on the same filter filed again,     // will toggle off the single filter field,     // and allow multi-edit all checked filter fields.     if (nextActiveFilterField === currentActiveFilterField) {       const filterScopeTreeEntry = buildFilterScopeTreeEntry({         checkedFilterFields,         activeFilterField: null,         filterScopeMap,         layout,       });        this.setState({         activeFilterField: null,         filterScopeMap: {           ...filterScopeMap,           ...filterScopeTreeEntry,         },       });     } else if (this.allfilterFields.includes(nextActiveFilterField)) {       const filterScopeTreeEntry = buildFilterScopeTreeEntry({         checkedFilterFields,         activeFilterField: nextActiveFilterField,         filterScopeMap,         layout,       });        this.setState({         activeFilterField: nextActiveFilterField,         filterScopeMap: {           ...filterScopeMap,           ...filterScopeTreeEntry,         },       });     }   }    onSearchInputChange(e) {     this.setState({ searchText: e.target.value }, this.filterTree);   }    onClose() {     this.props.onCloseModal();   }    onSave() {     const { filterScopeMap } = this.state;      const allFilterFieldScopes = this.allfilterFields.reduce(       (map, filterKey) => {         const { nodes } = filterScopeMap[filterKey];         const checkedChartIds = filterScopeMap[filterKey].checked;          return {           ...map,           [filterKey]: getFilterScopeFromNodesTree({             filterKey,             nodes,             checkedChartIds,           }),         };       },       {},     );      this.props.updateDashboardFiltersScope(allFilterFieldScopes);     this.props.setUnsavedChanges(true);      // click Save button will do save and close modal     this.props.onCloseModal();   }    filterTree() {     // Reset nodes back to unfiltered state     if (!this.state.searchText) {       this.setState(prevState => {         const { activeFilterField, checkedFilterFields, filterScopeMap } =           prevState;         const key = getKeyForFilterScopeTree({           activeFilterField,           checkedFilterFields,         });          const updatedEntry = {           ...filterScopeMap[key],           nodesFiltered: filterScopeMap[key].nodes,         };         return {           filterScopeMap: {             ...filterScopeMap,             [key]: updatedEntry,           },         };       });     } else {       const updater = prevState => {         const { activeFilterField, checkedFilterFields, filterScopeMap } =           prevState;         const key = getKeyForFilterScopeTree({           activeFilterField,           checkedFilterFields,         });          const nodesFiltered = filterScopeMap[key].nodes.reduce(           this.filterNodes,           [],         );         const expanded = getFilterScopeParentNodes([...nodesFiltered]);         const updatedEntry = {           ...filterScopeMap[key],           nodesFiltered,           expanded,         };          return {           filterScopeMap: {             ...filterScopeMap,             [key]: updatedEntry,           },         };       };        this.setState(updater);     }   }    filterNodes(filtered = [], node = {}) {     const { searchText } = this.state;     const children = (node.children || []).reduce(this.filterNodes, []);      if (       // Node's label matches the search string       node.label.toLocaleLowerCase().indexOf(searchText.toLocaleLowerCase()) >         -1 ||       // Or a children has a matching node       children.length     ) {       filtered.push({ ...node, children });     }      return filtered;   }    renderFilterFieldList() {     const {       activeFilterField,       filterFieldNodes,       checkedFilterFields,       expandedFilterIds,     } = this.state;     return (       <FilterFieldTree         activeKey={activeFilterField}         nodes={filterFieldNodes}         checked={checkedFilterFields}         expanded={expandedFilterIds}         onClick={this.onChangeFilterField}         onCheck={this.onCheckFilterField}         onExpand={this.onExpandFilterField}       />     );   }    renderFilterScopeTree() {     const {       filterScopeMap,       activeFilterField,       checkedFilterFields,       searchText,     } = this.state;      const key = getKeyForFilterScopeTree({       activeFilterField,       checkedFilterFields,     });      const selectedChartId = getSelectedChartIdForFilterScopeTree({       activeFilterField,       checkedFilterFields,     });     return (       <>         <input           className=""filter-text scope-search multi-edit-mode""           placeholder={t('Search...')}           type=""text""           value={searchText}           onChange={this.onSearchInputChange}         />         <FilterScopeTree           nodes={filterScopeMap[key].nodesFiltered}           checked={filterScopeMap[key].checked}           expanded={filterScopeMap[key].expanded}           onCheck={this.onCheckFilterScope}           onExpand={this.onExpandFilterScope}           // pass selectedFilterId prop to FilterScopeTree component,           // to hide checkbox for selected filter field itself           selectedChartId={selectedChartId}         />       </>     );   }    renderEditingFiltersName() {     const { dashboardFilters } = this.props;     const { activeFilterField, checkedFilterFields } = this.state;     const currentFilterLabels = []       .concat(activeFilterField || checkedFilterFields)       .map(key => {         const { chartId, column } = getChartIdAndColumnFromFilterKey(key);         return dashboardFilters[chartId].labels[column] || column;       });      return (       <div className=""selected-fields multi-edit-mode"">         {currentFilterLabels.length === 0 && t('No filter is selected.')}         {currentFilterLabels.length === 1 && t('Editing 1 filter:')}         {currentFilterLabels.length > 1 &&           t('Batch editing %d filters:', currentFilterLabels.length)}         <span className=""selected-scopes"">           {currentFilterLabels.join(', ')}         </span>       </div>     );   }    render() {     const { showSelector } = this.state;      return (       <ScopeContainer>         <ScopeHeader>           <h4>{t('Configure filter scopes')}</h4>           {showSelector && this.renderEditingFiltersName()}         </ScopeHeader>          <ScopeBody className=""filter-scope-body"">           {!showSelector ? (             <div className=""warning-message"">               {t('There are no filters in this dashboard.')}             </div>           ) : (             <ScopeSelector className=""filters-scope-selector"">               <div className={cx('filter-field-pane multi-edit-mode')}>                 {this.renderFilterFieldList()}               </div>               <div className=""filter-scope-pane multi-edit-mode"">                 {this.renderFilterScopeTree()}               </div>             </ScopeSelector>           )}         </ScopeBody>          <ActionsContainer>           <Button buttonSize=""small"" onClick={this.onClose}>             {t('Close')}           </Button>           {showSelector && (             <Button               buttonSize=""small""               buttonStyle=""primary""               onClick={this.onSave}             >               {t('Save')}             </Button>           )}         </ActionsContainer>       </ScopeContainer>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_30_214.js
as_31_217,Inefficient Rendering,"class Chart extends React.Component {   constructor(props) {     super(props);     this.state = {       width: props.width,       height: props.height,       descriptionHeight: 0,     };      this.changeFilter = this.changeFilter.bind(this);     this.handleFilterMenuOpen = this.handleFilterMenuOpen.bind(this);     this.handleFilterMenuClose = this.handleFilterMenuClose.bind(this);     this.exportCSV = this.exportCSV.bind(this);     this.exportFullCSV = this.exportFullCSV.bind(this);     this.exportXLSX = this.exportXLSX.bind(this);     this.forceRefresh = this.forceRefresh.bind(this);     this.resize = this.resize.bind(this);     this.setDescriptionRef = this.setDescriptionRef.bind(this);     this.setHeaderRef = this.setHeaderRef.bind(this);     this.getChartHeight = this.getChartHeight.bind(this);     this.getDescriptionHeight = this.getDescriptionHeight.bind(this);   }    shouldComponentUpdate(nextProps, nextState) {     // this logic mostly pertains to chart resizing. we keep a copy of the dimensions in     // state so that we can buffer component size updates and only update on the final call     // which improves performance significantly     if (       nextState.width !== this.state.width ||       nextState.height !== this.state.height ||       nextState.descriptionHeight !== this.state.descriptionHeight ||       !isEqual(nextProps.datasource, this.props.datasource)     ) {       return true;     }      // allow chart to update if the status changed and the previous status was loading.     if (       this.props?.chart?.chartStatus !== nextProps?.chart?.chartStatus &&       this.props?.chart?.chartStatus === 'loading'     ) {       return true;     }      // allow chart update/re-render only if visible:     // under selected tab or no tab layout     if (nextProps.isComponentVisible) {       if (nextProps.chart.triggerQuery) {         return true;       }        if (nextProps.isFullSize !== this.props.isFullSize) {         clearTimeout(this.resizeTimeout);         this.resizeTimeout = setTimeout(this.resize, RESIZE_TIMEOUT);         return false;       }        if (         nextProps.width !== this.props.width ||         nextProps.height !== this.props.height ||         nextProps.width !== this.state.width ||         nextProps.height !== this.state.height       ) {         clearTimeout(this.resizeTimeout);         this.resizeTimeout = setTimeout(this.resize, RESIZE_TIMEOUT);       }        for (let i = 0; i < SHOULD_UPDATE_ON_PROP_CHANGES.length; i += 1) {         const prop = SHOULD_UPDATE_ON_PROP_CHANGES[i];         // use deep objects equality comparison to prevent         // unnecessary updates when objects references change         if (!areObjectsEqual(nextProps[prop], this.props[prop])) {           return true;         }       }     } else if (       // chart should re-render if color scheme or label color was changed       nextProps.formData?.color_scheme !== this.props.formData?.color_scheme ||       !areObjectsEqual(         nextProps.formData?.label_colors,         this.props.formData?.label_colors,       )     ) {       return true;     }      // `cacheBusterProp` is jected by react-hot-loader     return this.props.cacheBusterProp !== nextProps.cacheBusterProp;   }    componentDidMount() {     if (this.props.isExpanded) {       const descriptionHeight = this.getDescriptionHeight();       this.setState({ descriptionHeight });     }   }    componentWillUnmount() {     clearTimeout(this.resizeTimeout);   }    componentDidUpdate(prevProps) {     if (this.props.isExpanded !== prevProps.isExpanded) {       const descriptionHeight = this.getDescriptionHeight();       // eslint-disable-next-line react/no-did-update-set-state       this.setState({ descriptionHeight });     }   }    getDescriptionHeight() {     return this.props.isExpanded && this.descriptionRef       ? this.descriptionRef.offsetHeight       : 0;   }    getChartHeight() {     const headerHeight = this.getHeaderHeight();     return Math.max(       this.state.height - headerHeight - this.state.descriptionHeight,       20,     );   }    getHeaderHeight() {     if (this.headerRef) {       const computedStyle = getComputedStyle(this.headerRef).getPropertyValue(         'margin-bottom',       );       const marginBottom = parseInt(computedStyle, 10) || 0;       return this.headerRef.offsetHeight + marginBottom;     }     return DEFAULT_HEADER_HEIGHT;   }    setDescriptionRef(ref) {     this.descriptionRef = ref;   }    setHeaderRef(ref) {     this.headerRef = ref;   }    resize() {     const { width, height } = this.props;     this.setState(() => ({ width, height }));   }    changeFilter(newSelectedValues = {}) {     this.props.logEvent(LOG_ACTIONS_CHANGE_DASHBOARD_FILTER, {       id: this.props.chart.id,       columns: Object.keys(newSelectedValues),     });     this.props.changeFilter(this.props.chart.id, newSelectedValues);   }    handleFilterMenuOpen(chartId, column) {     this.props.setFocusedFilterField(chartId, column);   }    handleFilterMenuClose(chartId, column) {     this.props.unsetFocusedFilterField(chartId, column);   }    logExploreChart = () => {     this.props.logEvent(LOG_ACTIONS_EXPLORE_DASHBOARD_CHART, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });   };    onExploreChart = async clickEvent => {     const isOpenInNewTab =       clickEvent.shiftKey || clickEvent.ctrlKey || clickEvent.metaKey;     try {       const lastTabId = window.localStorage.getItem('last_tab_id');       const nextTabId = lastTabId         ? String(Number.parseInt(lastTabId, 10) + 1)         : undefined;       const key = await postFormData(         this.props.datasource.id,         this.props.datasource.type,         this.props.formData,         this.props.slice.slice_id,         nextTabId,       );       const url = mountExploreUrl(null, {         [URL_PARAMS.formDataKey.name]: key,         [URL_PARAMS.sliceId.name]: this.props.slice.slice_id,       });       if (isOpenInNewTab) {         window.open(url, '_blank', 'noreferrer');       } else {         this.props.history.push(url);       }     } catch (error) {       logging.error(error);       this.props.addDangerToast(t('An error occurred while opening Explore'));     }   };    exportFullCSV() {     this.exportCSV(true);   }    exportCSV(isFullCSV = false) {     this.exportTable('csv', isFullCSV);   }    exportXLSX() {     this.exportTable('xlsx', false);   }    exportTable(format, isFullCSV) {     const logAction =       format === 'csv'         ? LOG_ACTIONS_EXPORT_CSV_DASHBOARD_CHART         : LOG_ACTIONS_EXPORT_XLSX_DASHBOARD_CHART;     this.props.logEvent(logAction, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });     exportChart({       formData: isFullCSV         ? { ...this.props.formData, row_limit: this.props.maxRows }         : this.props.formData,       resultType: 'full',       resultFormat: format,       force: true,       ownState: this.props.ownState,     });   }    forceRefresh() {     this.props.logEvent(LOG_ACTIONS_FORCE_REFRESH_CHART, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });     return this.props.refreshChart(       this.props.chart.id,       true,       this.props.dashboardId,     );   }    render() {     const {       id,       componentId,       dashboardId,       chart,       slice,       datasource,       isExpanded,       editMode,       filters,       formData,       labelColors,       sharedLabelColors,       updateSliceName,       sliceName,       toggleExpandSlice,       timeout,       supersetCanExplore,       supersetCanShare,       supersetCanCSV,       sliceCanEdit,       addSuccessToast,       addDangerToast,       ownState,       filterState,       handleToggleFullSize,       isFullSize,       setControlValue,       postTransformProps,       datasetsStatus,       isInView,       emitCrossFilters,       logEvent,     } = this.props;      const { width } = this.state;     // this prevents throwing in the case that a gridComponent     // references a chart that is not associated with the dashboard     if (!chart || !slice) {       return <MissingChart height={this.getChartHeight()} />;     }      const { queriesResponse, chartUpdateEndTime, chartStatus } = chart;     const isLoading = chartStatus === 'loading';     // eslint-disable-next-line camelcase     const isCached = queriesResponse?.map(({ is_cached }) => is_cached) || [];     const cachedDttm =       // eslint-disable-next-line camelcase       queriesResponse?.map(({ cached_dttm }) => cached_dttm) || [];     const isOverflowable = OVERFLOWABLE_VIZ_TYPES.has(slice.viz_type);     const initialValues = isFilterBox(id)       ? getFilterValuesByFilterId({           activeFilters: filters,           filterId: id,         })       : {};      return (       <SliceContainer         className=""chart-slice""         data-test=""chart-grid-component""         data-test-chart-id={id}         data-test-viz-type={slice.viz_type}         data-test-chart-name={slice.slice_name}       >         <SliceHeader           innerRef={this.setHeaderRef}           slice={slice}           isExpanded={isExpanded}           isCached={isCached}           cachedDttm={cachedDttm}           updatedDttm={chartUpdateEndTime}           toggleExpandSlice={toggleExpandSlice}           forceRefresh={this.forceRefresh}           editMode={editMode}           annotationQuery={chart.annotationQuery}           logExploreChart={this.logExploreChart}           logEvent={logEvent}           onExploreChart={this.onExploreChart}           exportCSV={this.exportCSV}           exportXLSX={this.exportXLSX}           exportFullCSV={this.exportFullCSV}           updateSliceName={updateSliceName}           sliceName={sliceName}           supersetCanExplore={supersetCanExplore}           supersetCanShare={supersetCanShare}           supersetCanCSV={supersetCanCSV}           sliceCanEdit={sliceCanEdit}           componentId={componentId}           dashboardId={dashboardId}           filters={filters}           addSuccessToast={addSuccessToast}           addDangerToast={addDangerToast}           handleToggleFullSize={handleToggleFullSize}           isFullSize={isFullSize}           chartStatus={chart.chartStatus}           formData={formData}           width={width}           height={this.getHeaderHeight()}         />          {/*           This usage of dangerouslySetInnerHTML is safe since it is being used to render           markdown that is sanitized with nh3. See:              https://github.com/apache/superset/pull/4390           and              https://github.com/apache/superset/pull/23862         */}         {isExpanded && slice.description_markeddown && (           <div             className=""slice_description bs-callout bs-callout-default""             ref={this.setDescriptionRef}             // eslint-disable-next-line react/no-danger             dangerouslySetInnerHTML={{ __html: slice.description_markeddown }}           />         )}          <ChartWrapper           className={cx(             'dashboard-chart',             isOverflowable && 'dashboard-chart--overflowable',           )}         >           {isLoading && (             <ChartOverlay               style={{                 width,                 height: this.getChartHeight(),               }}             />           )}            <ChartContainer             width={width}             height={this.getChartHeight()}             addFilter={this.changeFilter}             onFilterMenuOpen={this.handleFilterMenuOpen}             onFilterMenuClose={this.handleFilterMenuClose}             annotationData={chart.annotationData}             chartAlert={chart.chartAlert}             chartId={id}             chartStatus={chartStatus}             datasource={datasource}             dashboardId={dashboardId}             initialValues={initialValues}             formData={formData}             labelColors={labelColors}             sharedLabelColors={sharedLabelColors}             ownState={ownState}             filterState={filterState}             queriesResponse={chart.queriesResponse}             timeout={timeout}             triggerQuery={chart.triggerQuery}             vizType={slice.viz_type}             setControlValue={setControlValue}             postTransformProps={postTransformProps}             datasetsStatus={datasetsStatus}             isInView={isInView}             emitCrossFilters={emitCrossFilters}           />         </ChartWrapper>       </SliceContainer>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_31_217.js
as_32_218,Props in initial state,"class Chart extends React.Component {   constructor(props) {     super(props);     this.state = {       width: props.width,       height: props.height,       descriptionHeight: 0,     };      this.changeFilter = this.changeFilter.bind(this);     this.handleFilterMenuOpen = this.handleFilterMenuOpen.bind(this);     this.handleFilterMenuClose = this.handleFilterMenuClose.bind(this);     this.exportCSV = this.exportCSV.bind(this);     this.exportFullCSV = this.exportFullCSV.bind(this);     this.exportXLSX = this.exportXLSX.bind(this);     this.forceRefresh = this.forceRefresh.bind(this);     this.resize = this.resize.bind(this);     this.setDescriptionRef = this.setDescriptionRef.bind(this);     this.setHeaderRef = this.setHeaderRef.bind(this);     this.getChartHeight = this.getChartHeight.bind(this);     this.getDescriptionHeight = this.getDescriptionHeight.bind(this);   }    shouldComponentUpdate(nextProps, nextState) {     // this logic mostly pertains to chart resizing. we keep a copy of the dimensions in     // state so that we can buffer component size updates and only update on the final call     // which improves performance significantly     if (       nextState.width !== this.state.width ||       nextState.height !== this.state.height ||       nextState.descriptionHeight !== this.state.descriptionHeight ||       !isEqual(nextProps.datasource, this.props.datasource)     ) {       return true;     }      // allow chart to update if the status changed and the previous status was loading.     if (       this.props?.chart?.chartStatus !== nextProps?.chart?.chartStatus &&       this.props?.chart?.chartStatus === 'loading'     ) {       return true;     }      // allow chart update/re-render only if visible:     // under selected tab or no tab layout     if (nextProps.isComponentVisible) {       if (nextProps.chart.triggerQuery) {         return true;       }        if (nextProps.isFullSize !== this.props.isFullSize) {         clearTimeout(this.resizeTimeout);         this.resizeTimeout = setTimeout(this.resize, RESIZE_TIMEOUT);         return false;       }        if (         nextProps.width !== this.props.width ||         nextProps.height !== this.props.height ||         nextProps.width !== this.state.width ||         nextProps.height !== this.state.height       ) {         clearTimeout(this.resizeTimeout);         this.resizeTimeout = setTimeout(this.resize, RESIZE_TIMEOUT);       }        for (let i = 0; i < SHOULD_UPDATE_ON_PROP_CHANGES.length; i += 1) {         const prop = SHOULD_UPDATE_ON_PROP_CHANGES[i];         // use deep objects equality comparison to prevent         // unnecessary updates when objects references change         if (!areObjectsEqual(nextProps[prop], this.props[prop])) {           return true;         }       }     } else if (       // chart should re-render if color scheme or label color was changed       nextProps.formData?.color_scheme !== this.props.formData?.color_scheme ||       !areObjectsEqual(         nextProps.formData?.label_colors,         this.props.formData?.label_colors,       )     ) {       return true;     }      // `cacheBusterProp` is jected by react-hot-loader     return this.props.cacheBusterProp !== nextProps.cacheBusterProp;   }    componentDidMount() {     if (this.props.isExpanded) {       const descriptionHeight = this.getDescriptionHeight();       this.setState({ descriptionHeight });     }   }    componentWillUnmount() {     clearTimeout(this.resizeTimeout);   }    componentDidUpdate(prevProps) {     if (this.props.isExpanded !== prevProps.isExpanded) {       const descriptionHeight = this.getDescriptionHeight();       // eslint-disable-next-line react/no-did-update-set-state       this.setState({ descriptionHeight });     }   }    getDescriptionHeight() {     return this.props.isExpanded && this.descriptionRef       ? this.descriptionRef.offsetHeight       : 0;   }    getChartHeight() {     const headerHeight = this.getHeaderHeight();     return Math.max(       this.state.height - headerHeight - this.state.descriptionHeight,       20,     );   }    getHeaderHeight() {     if (this.headerRef) {       const computedStyle = getComputedStyle(this.headerRef).getPropertyValue(         'margin-bottom',       );       const marginBottom = parseInt(computedStyle, 10) || 0;       return this.headerRef.offsetHeight + marginBottom;     }     return DEFAULT_HEADER_HEIGHT;   }    setDescriptionRef(ref) {     this.descriptionRef = ref;   }    setHeaderRef(ref) {     this.headerRef = ref;   }    resize() {     const { width, height } = this.props;     this.setState(() => ({ width, height }));   }    changeFilter(newSelectedValues = {}) {     this.props.logEvent(LOG_ACTIONS_CHANGE_DASHBOARD_FILTER, {       id: this.props.chart.id,       columns: Object.keys(newSelectedValues),     });     this.props.changeFilter(this.props.chart.id, newSelectedValues);   }    handleFilterMenuOpen(chartId, column) {     this.props.setFocusedFilterField(chartId, column);   }    handleFilterMenuClose(chartId, column) {     this.props.unsetFocusedFilterField(chartId, column);   }    logExploreChart = () => {     this.props.logEvent(LOG_ACTIONS_EXPLORE_DASHBOARD_CHART, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });   };    onExploreChart = async clickEvent => {     const isOpenInNewTab =       clickEvent.shiftKey || clickEvent.ctrlKey || clickEvent.metaKey;     try {       const lastTabId = window.localStorage.getItem('last_tab_id');       const nextTabId = lastTabId         ? String(Number.parseInt(lastTabId, 10) + 1)         : undefined;       const key = await postFormData(         this.props.datasource.id,         this.props.datasource.type,         this.props.formData,         this.props.slice.slice_id,         nextTabId,       );       const url = mountExploreUrl(null, {         [URL_PARAMS.formDataKey.name]: key,         [URL_PARAMS.sliceId.name]: this.props.slice.slice_id,       });       if (isOpenInNewTab) {         window.open(url, '_blank', 'noreferrer');       } else {         this.props.history.push(url);       }     } catch (error) {       logging.error(error);       this.props.addDangerToast(t('An error occurred while opening Explore'));     }   };    exportFullCSV() {     this.exportCSV(true);   }    exportCSV(isFullCSV = false) {     this.exportTable('csv', isFullCSV);   }    exportXLSX() {     this.exportTable('xlsx', false);   }    exportTable(format, isFullCSV) {     const logAction =       format === 'csv'         ? LOG_ACTIONS_EXPORT_CSV_DASHBOARD_CHART         : LOG_ACTIONS_EXPORT_XLSX_DASHBOARD_CHART;     this.props.logEvent(logAction, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });     exportChart({       formData: isFullCSV         ? { ...this.props.formData, row_limit: this.props.maxRows }         : this.props.formData,       resultType: 'full',       resultFormat: format,       force: true,       ownState: this.props.ownState,     });   }    forceRefresh() {     this.props.logEvent(LOG_ACTIONS_FORCE_REFRESH_CHART, {       slice_id: this.props.slice.slice_id,       is_cached: this.props.isCached,     });     return this.props.refreshChart(       this.props.chart.id,       true,       this.props.dashboardId,     );   }    render() {     const {       id,       componentId,       dashboardId,       chart,       slice,       datasource,       isExpanded,       editMode,       filters,       formData,       labelColors,       sharedLabelColors,       updateSliceName,       sliceName,       toggleExpandSlice,       timeout,       supersetCanExplore,       supersetCanShare,       supersetCanCSV,       sliceCanEdit,       addSuccessToast,       addDangerToast,       ownState,       filterState,       handleToggleFullSize,       isFullSize,       setControlValue,       postTransformProps,       datasetsStatus,       isInView,       emitCrossFilters,       logEvent,     } = this.props;      const { width } = this.state;     // this prevents throwing in the case that a gridComponent     // references a chart that is not associated with the dashboard     if (!chart || !slice) {       return <MissingChart height={this.getChartHeight()} />;     }      const { queriesResponse, chartUpdateEndTime, chartStatus } = chart;     const isLoading = chartStatus === 'loading';     // eslint-disable-next-line camelcase     const isCached = queriesResponse?.map(({ is_cached }) => is_cached) || [];     const cachedDttm =       // eslint-disable-next-line camelcase       queriesResponse?.map(({ cached_dttm }) => cached_dttm) || [];     const isOverflowable = OVERFLOWABLE_VIZ_TYPES.has(slice.viz_type);     const initialValues = isFilterBox(id)       ? getFilterValuesByFilterId({           activeFilters: filters,           filterId: id,         })       : {};      return (       <SliceContainer         className=""chart-slice""         data-test=""chart-grid-component""         data-test-chart-id={id}         data-test-viz-type={slice.viz_type}         data-test-chart-name={slice.slice_name}       >         <SliceHeader           innerRef={this.setHeaderRef}           slice={slice}           isExpanded={isExpanded}           isCached={isCached}           cachedDttm={cachedDttm}           updatedDttm={chartUpdateEndTime}           toggleExpandSlice={toggleExpandSlice}           forceRefresh={this.forceRefresh}           editMode={editMode}           annotationQuery={chart.annotationQuery}           logExploreChart={this.logExploreChart}           logEvent={logEvent}           onExploreChart={this.onExploreChart}           exportCSV={this.exportCSV}           exportXLSX={this.exportXLSX}           exportFullCSV={this.exportFullCSV}           updateSliceName={updateSliceName}           sliceName={sliceName}           supersetCanExplore={supersetCanExplore}           supersetCanShare={supersetCanShare}           supersetCanCSV={supersetCanCSV}           sliceCanEdit={sliceCanEdit}           componentId={componentId}           dashboardId={dashboardId}           filters={filters}           addSuccessToast={addSuccessToast}           addDangerToast={addDangerToast}           handleToggleFullSize={handleToggleFullSize}           isFullSize={isFullSize}           chartStatus={chart.chartStatus}           formData={formData}           width={width}           height={this.getHeaderHeight()}         />          {/*           This usage of dangerouslySetInnerHTML is safe since it is being used to render           markdown that is sanitized with nh3. See:              https://github.com/apache/superset/pull/4390           and              https://github.com/apache/superset/pull/23862         */}         {isExpanded && slice.description_markeddown && (           <div             className=""slice_description bs-callout bs-callout-default""             ref={this.setDescriptionRef}             // eslint-disable-next-line react/no-danger             dangerouslySetInnerHTML={{ __html: slice.description_markeddown }}           />         )}          <ChartWrapper           className={cx(             'dashboard-chart',             isOverflowable && 'dashboard-chart--overflowable',           )}         >           {isLoading && (             <ChartOverlay               style={{                 width,                 height: this.getChartHeight(),               }}             />           )}            <ChartContainer             width={width}             height={this.getChartHeight()}             addFilter={this.changeFilter}             onFilterMenuOpen={this.handleFilterMenuOpen}             onFilterMenuClose={this.handleFilterMenuClose}             annotationData={chart.annotationData}             chartAlert={chart.chartAlert}             chartId={id}             chartStatus={chartStatus}             datasource={datasource}             dashboardId={dashboardId}             initialValues={initialValues}             formData={formData}             labelColors={labelColors}             sharedLabelColors={sharedLabelColors}             ownState={ownState}             filterState={filterState}             queriesResponse={chart.queriesResponse}             timeout={timeout}             triggerQuery={chart.triggerQuery}             vizType={slice.viz_type}             setControlValue={setControlValue}             postTransformProps={postTransformProps}             datasetsStatus={datasetsStatus}             isInView={isInView}             emitCrossFilters={emitCrossFilters}           />         </ChartWrapper>       </SliceContainer>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_32_218.js
as_33_229,Inefficient Rendering,"class Markdown extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       isFocused: false,       markdownSource: props.component.meta.code,       editor: null,       editorMode: 'preview',       undoLength: props.undoLength,       redoLength: props.redoLength,     };     this.renderStartTime = Logger.getTimestamp();      this.handleChangeFocus = this.handleChangeFocus.bind(this);     this.handleChangeEditorMode = this.handleChangeEditorMode.bind(this);     this.handleMarkdownChange = this.handleMarkdownChange.bind(this);     this.handleDeleteComponent = this.handleDeleteComponent.bind(this);     this.handleResizeStart = this.handleResizeStart.bind(this);     this.setEditor = this.setEditor.bind(this);   }    componentDidMount() {     this.props.logEvent(LOG_ACTIONS_RENDER_CHART, {       viz_type: 'markdown',       start_offset: this.renderStartTime,       ts: new Date().getTime(),       duration: Logger.getTimestamp() - this.renderStartTime,     });   }    static getDerivedStateFromProps(nextProps, state) {     const { hasError, editorMode, markdownSource, undoLength, redoLength } =       state;     const {       component: nextComponent,       undoLength: nextUndoLength,       redoLength: nextRedoLength,     } = nextProps;     // user click undo or redo ?     if (nextUndoLength !== undoLength || nextRedoLength !== redoLength) {       return {         ...state,         undoLength: nextUndoLength,         redoLength: nextRedoLength,         markdownSource: nextComponent.meta.code,         hasError: false,       };     }     if (       !hasError &&       editorMode === 'preview' &&       nextComponent.meta.code !== markdownSource     ) {       return {         ...state,         markdownSource: nextComponent.meta.code,       };     }      return state;   }    static getDerivedStateFromError() {     return {       hasError: true,     };   }    componentDidUpdate(prevProps) {     if (       this.state.editor &&       (prevProps.component.meta.width !== this.props.component.meta.width ||         prevProps.columnWidth !== this.props.columnWidth)     ) {       this.state.editor.resize(true);     }     // pre-load AceEditor when entering edit mode     if (this.props.editMode) {       MarkdownEditor.preload();     }   }    componentDidCatch() {     if (this.state.editor && this.state.editorMode === 'preview') {       this.props.addDangerToast(         t(           'This markdown component has an error. Please revert your recent changes.',         ),       );     }   }    setEditor(editor) {     editor.getSession().setUseWrapMode(true);     this.setState({       editor,     });   }    handleChangeFocus(nextFocus) {     const nextFocused = !!nextFocus;     const nextEditMode = nextFocused ? 'edit' : 'preview';     this.setState(() => ({ isFocused: nextFocused }));     this.handleChangeEditorMode(nextEditMode);   }    handleChangeEditorMode(mode) {     const nextState = {       ...this.state,       editorMode: mode,     };     if (mode === 'preview') {       this.updateMarkdownContent();       nextState.hasError = false;     }      this.setState(nextState);   }    updateMarkdownContent() {     const { updateComponents, component } = this.props;     if (component.meta.code !== this.state.markdownSource) {       updateComponents({         [component.id]: {           ...component,           meta: {             ...component.meta,             code: this.state.markdownSource,           },         },       });     }   }    handleMarkdownChange(nextValue) {     this.setState({       markdownSource: nextValue,     });   }    handleDeleteComponent() {     const { deleteComponent, id, parentId } = this.props;     deleteComponent(id, parentId);   }    handleResizeStart(e) {     const { editorMode } = this.state;     const { editMode, onResizeStart } = this.props;     const isEditing = editorMode === 'edit';     onResizeStart(e);     if (editMode && isEditing) {       this.updateMarkdownContent();     }   }    renderEditMode() {     return (       <MarkdownEditor         onChange={this.handleMarkdownChange}         width=""100%""         height=""100%""         showGutter={false}         editorProps={{ $blockScrolling: true }}         value={           // this allows ""select all => delete"" to give an empty editor           typeof this.state.markdownSource === 'string'             ? this.state.markdownSource             : MARKDOWN_PLACE_HOLDER         }         readOnly={false}         onLoad={this.setEditor}         data-test=""editor""       />     );   }    renderPreviewMode() {     const { hasError } = this.state;      return (       <SafeMarkdown         source={           hasError             ? MARKDOWN_ERROR_MESSAGE             : this.state.markdownSource || MARKDOWN_PLACE_HOLDER         }         htmlSanitization={this.props.htmlSanitization}         htmlSchemaOverrides={this.props.htmlSchemaOverrides}       />     );   }    render() {     const { isFocused, editorMode } = this.state;      const {       component,       parentComponent,       index,       depth,       availableColumnCount,       columnWidth,       onResize,       onResizeStop,       handleComponentDrop,       editMode,     } = this.props;      // inherit the size of parent columns     const widthMultiple =       parentComponent.type === COLUMN_TYPE         ? parentComponent.meta.width || GRID_MIN_COLUMN_COUNT         : component.meta.width || GRID_MIN_COLUMN_COUNT;      const isEditing = editorMode === 'edit';      return (       <DragDroppable         component={component}         parentComponent={parentComponent}         orientation={parentComponent.type === ROW_TYPE ? 'column' : 'row'}         index={index}         depth={depth}         onDrop={handleComponentDrop}         disableDragDrop={isFocused}         editMode={editMode}       >         {({ dropIndicatorProps, dragSourceRef }) => (           <WithPopoverMenu             onChangeFocus={this.handleChangeFocus}             menuItems={[               <MarkdownModeDropdown                 id={`${component.id}-mode`}                 value={this.state.editorMode}                 onChange={this.handleChangeEditorMode}               />,             ]}             editMode={editMode}           >             <MarkdownStyles               data-test=""dashboard-markdown-editor""               className={cx(                 'dashboard-markdown',                 isEditing && 'dashboard-markdown--editing',               )}               id={component.id}             >               <ResizableContainer                 id={component.id}                 adjustableWidth={parentComponent.type === ROW_TYPE}                 adjustableHeight                 widthStep={columnWidth}                 widthMultiple={widthMultiple}                 heightStep={GRID_BASE_UNIT}                 heightMultiple={component.meta.height}                 minWidthMultiple={GRID_MIN_COLUMN_COUNT}                 minHeightMultiple={GRID_MIN_ROW_UNITS}                 maxWidthMultiple={availableColumnCount + widthMultiple}                 onResizeStart={this.handleResizeStart}                 onResize={onResize}                 onResizeStop={onResizeStop}                 editMode={isFocused ? false : editMode}               >                 <div                   ref={dragSourceRef}                   className=""dashboard-component dashboard-component-chart-holder""                   data-test=""dashboard-component-chart-holder""                 >                   {editMode && (                     <HoverMenu position=""top"">                       <DeleteComponentButton                         onDelete={this.handleDeleteComponent}                       />                     </HoverMenu>                   )}                   {editMode && isEditing                     ? this.renderEditMode()                     : this.renderPreviewMode()}                 </div>               </ResizableContainer>             </MarkdownStyles>             {dropIndicatorProps && <div {...dropIndicatorProps} />}           </WithPopoverMenu>         )}       </DragDroppable>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_33_229.js
as_34_230,Props in initial state,"class Markdown extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       isFocused: false,       markdownSource: props.component.meta.code,       editor: null,       editorMode: 'preview',       undoLength: props.undoLength,       redoLength: props.redoLength,     };     this.renderStartTime = Logger.getTimestamp();      this.handleChangeFocus = this.handleChangeFocus.bind(this);     this.handleChangeEditorMode = this.handleChangeEditorMode.bind(this);     this.handleMarkdownChange = this.handleMarkdownChange.bind(this);     this.handleDeleteComponent = this.handleDeleteComponent.bind(this);     this.handleResizeStart = this.handleResizeStart.bind(this);     this.setEditor = this.setEditor.bind(this);   }    componentDidMount() {     this.props.logEvent(LOG_ACTIONS_RENDER_CHART, {       viz_type: 'markdown',       start_offset: this.renderStartTime,       ts: new Date().getTime(),       duration: Logger.getTimestamp() - this.renderStartTime,     });   }    static getDerivedStateFromProps(nextProps, state) {     const { hasError, editorMode, markdownSource, undoLength, redoLength } =       state;     const {       component: nextComponent,       undoLength: nextUndoLength,       redoLength: nextRedoLength,     } = nextProps;     // user click undo or redo ?     if (nextUndoLength !== undoLength || nextRedoLength !== redoLength) {       return {         ...state,         undoLength: nextUndoLength,         redoLength: nextRedoLength,         markdownSource: nextComponent.meta.code,         hasError: false,       };     }     if (       !hasError &&       editorMode === 'preview' &&       nextComponent.meta.code !== markdownSource     ) {       return {         ...state,         markdownSource: nextComponent.meta.code,       };     }      return state;   }    static getDerivedStateFromError() {     return {       hasError: true,     };   }    componentDidUpdate(prevProps) {     if (       this.state.editor &&       (prevProps.component.meta.width !== this.props.component.meta.width ||         prevProps.columnWidth !== this.props.columnWidth)     ) {       this.state.editor.resize(true);     }     // pre-load AceEditor when entering edit mode     if (this.props.editMode) {       MarkdownEditor.preload();     }   }    componentDidCatch() {     if (this.state.editor && this.state.editorMode === 'preview') {       this.props.addDangerToast(         t(           'This markdown component has an error. Please revert your recent changes.',         ),       );     }   }    setEditor(editor) {     editor.getSession().setUseWrapMode(true);     this.setState({       editor,     });   }    handleChangeFocus(nextFocus) {     const nextFocused = !!nextFocus;     const nextEditMode = nextFocused ? 'edit' : 'preview';     this.setState(() => ({ isFocused: nextFocused }));     this.handleChangeEditorMode(nextEditMode);   }    handleChangeEditorMode(mode) {     const nextState = {       ...this.state,       editorMode: mode,     };     if (mode === 'preview') {       this.updateMarkdownContent();       nextState.hasError = false;     }      this.setState(nextState);   }    updateMarkdownContent() {     const { updateComponents, component } = this.props;     if (component.meta.code !== this.state.markdownSource) {       updateComponents({         [component.id]: {           ...component,           meta: {             ...component.meta,             code: this.state.markdownSource,           },         },       });     }   }    handleMarkdownChange(nextValue) {     this.setState({       markdownSource: nextValue,     });   }    handleDeleteComponent() {     const { deleteComponent, id, parentId } = this.props;     deleteComponent(id, parentId);   }    handleResizeStart(e) {     const { editorMode } = this.state;     const { editMode, onResizeStart } = this.props;     const isEditing = editorMode === 'edit';     onResizeStart(e);     if (editMode && isEditing) {       this.updateMarkdownContent();     }   }    renderEditMode() {     return (       <MarkdownEditor         onChange={this.handleMarkdownChange}         width=""100%""         height=""100%""         showGutter={false}         editorProps={{ $blockScrolling: true }}         value={           // this allows ""select all => delete"" to give an empty editor           typeof this.state.markdownSource === 'string'             ? this.state.markdownSource             : MARKDOWN_PLACE_HOLDER         }         readOnly={false}         onLoad={this.setEditor}         data-test=""editor""       />     );   }    renderPreviewMode() {     const { hasError } = this.state;      return (       <SafeMarkdown         source={           hasError             ? MARKDOWN_ERROR_MESSAGE             : this.state.markdownSource || MARKDOWN_PLACE_HOLDER         }         htmlSanitization={this.props.htmlSanitization}         htmlSchemaOverrides={this.props.htmlSchemaOverrides}       />     );   }    render() {     const { isFocused, editorMode } = this.state;      const {       component,       parentComponent,       index,       depth,       availableColumnCount,       columnWidth,       onResize,       onResizeStop,       handleComponentDrop,       editMode,     } = this.props;      // inherit the size of parent columns     const widthMultiple =       parentComponent.type === COLUMN_TYPE         ? parentComponent.meta.width || GRID_MIN_COLUMN_COUNT         : component.meta.width || GRID_MIN_COLUMN_COUNT;      const isEditing = editorMode === 'edit';      return (       <DragDroppable         component={component}         parentComponent={parentComponent}         orientation={parentComponent.type === ROW_TYPE ? 'column' : 'row'}         index={index}         depth={depth}         onDrop={handleComponentDrop}         disableDragDrop={isFocused}         editMode={editMode}       >         {({ dropIndicatorProps, dragSourceRef }) => (           <WithPopoverMenu             onChangeFocus={this.handleChangeFocus}             menuItems={[               <MarkdownModeDropdown                 id={`${component.id}-mode`}                 value={this.state.editorMode}                 onChange={this.handleChangeEditorMode}               />,             ]}             editMode={editMode}           >             <MarkdownStyles               data-test=""dashboard-markdown-editor""               className={cx(                 'dashboard-markdown',                 isEditing && 'dashboard-markdown--editing',               )}               id={component.id}             >               <ResizableContainer                 id={component.id}                 adjustableWidth={parentComponent.type === ROW_TYPE}                 adjustableHeight                 widthStep={columnWidth}                 widthMultiple={widthMultiple}                 heightStep={GRID_BASE_UNIT}                 heightMultiple={component.meta.height}                 minWidthMultiple={GRID_MIN_COLUMN_COUNT}                 minHeightMultiple={GRID_MIN_ROW_UNITS}                 maxWidthMultiple={availableColumnCount + widthMultiple}                 onResizeStart={this.handleResizeStart}                 onResize={onResize}                 onResizeStop={onResizeStop}                 editMode={isFocused ? false : editMode}               >                 <div                   ref={dragSourceRef}                   className=""dashboard-component dashboard-component-chart-holder""                   data-test=""dashboard-component-chart-holder""                 >                   {editMode && (                     <HoverMenu position=""top"">                       <DeleteComponentButton                         onDelete={this.handleDeleteComponent}                       />                     </HoverMenu>                   )}                   {editMode && isEditing                     ? this.renderEditMode()                     : this.renderPreviewMode()}                 </div>               </ResizableContainer>             </MarkdownStyles>             {dropIndicatorProps && <div {...dropIndicatorProps} />}           </WithPopoverMenu>         )}       </DragDroppable>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_34_230.js
as_35_233,Inefficient Rendering,"class Row extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       isFocused: false,       isInView: false,     };     this.handleDeleteComponent = this.handleDeleteComponent.bind(this);     this.handleUpdateMeta = this.handleUpdateMeta.bind(this);     this.handleChangeBackground = this.handleUpdateMeta.bind(       this,       'background',     );     this.handleChangeFocus = this.handleChangeFocus.bind(this);      this.containerRef = React.createRef();     this.observerEnabler = null;     this.observerDisabler = null;   }    // if chart not rendered - render it if it's less than 1 view height away from current viewport   // if chart rendered - remove it if it's more than 4 view heights away from current viewport   componentDidMount() {     if (       isFeatureEnabled(FeatureFlag.DASHBOARD_VIRTUALIZATION) &&       !isCurrentUserBot()     ) {       this.observerEnabler = new IntersectionObserver(         ([entry]) => {           if (entry.isIntersecting && !this.state.isInView) {             this.setState({ isInView: true });           }         },         {           rootMargin: '100% 0px',         },       );       this.observerDisabler = new IntersectionObserver(         ([entry]) => {           if (!entry.isIntersecting && this.state.isInView) {             this.setState({ isInView: false });           }         },         {           rootMargin: '400% 0px',         },       );       const element = this.containerRef.current;       if (element) {         this.observerEnabler.observe(element);         this.observerDisabler.observe(element);       }     }   }    componentWillUnmount() {     this.observerEnabler?.disconnect();     this.observerDisabler?.disconnect();   }    handleChangeFocus(nextFocus) {     this.setState(() => ({ isFocused: Boolean(nextFocus) }));   }    handleUpdateMeta(metaKey, nextValue) {     const { updateComponents, component } = this.props;     if (nextValue && component.meta[metaKey] !== nextValue) {       updateComponents({         [component.id]: {           ...component,           meta: {             ...component.meta,             [metaKey]: nextValue,           },         },       });     }   }    handleDeleteComponent() {     const { deleteComponent, component, parentId } = this.props;     deleteComponent(component.id, parentId);   }    render() {     const {       component: rowComponent,       parentComponent,       index,       availableColumnCount,       columnWidth,       occupiedColumnCount,       depth,       onResizeStart,       onResize,       onResizeStop,       handleComponentDrop,       editMode,       onChangeTab,       isComponentVisible,     } = this.props;      const rowItems = rowComponent.children || [];      const backgroundStyle = backgroundStyleOptions.find(       opt =>         opt.value === (rowComponent.meta.background || BACKGROUND_TRANSPARENT),     );      return (       <DragDroppable         component={rowComponent}         parentComponent={parentComponent}         orientation=""row""         index={index}         depth={depth}         onDrop={handleComponentDrop}         editMode={editMode}       >         {({ dropIndicatorProps, dragSourceRef }) => (           <WithPopoverMenu             isFocused={this.state.isFocused}             onChangeFocus={this.handleChangeFocus}             disableClick             menuItems={[               <BackgroundStyleDropdown                 id={`${rowComponent.id}-background`}                 value={backgroundStyle.value}                 onChange={this.handleChangeBackground}               />,             ]}             editMode={editMode}           >             {editMode && (               <HoverMenu innerRef={dragSourceRef} position=""left"">                 <DragHandle position=""left"" />                 <DeleteComponentButton onDelete={this.handleDeleteComponent} />                 <IconButton                   onClick={this.handleChangeFocus}                   icon={<Icons.Cog iconSize=""xl"" />}                 />               </HoverMenu>             )}             <GridRow               className={cx(                 'grid-row',                 rowItems.length === 0 && 'grid-row--empty',                 backgroundStyle.className,               )}               data-test={`grid-row-${backgroundStyle.className}`}               ref={this.containerRef}             >               {rowItems.length === 0 ? (                 <div css={emptyRowContentStyles}>{t('Empty row')}</div>               ) : (                 rowItems.map((componentId, itemIndex) => (                   <DashboardComponent                     key={componentId}                     id={componentId}                     parentId={rowComponent.id}                     depth={depth + 1}                     index={itemIndex}                     availableColumnCount={                       availableColumnCount - occupiedColumnCount                     }                     columnWidth={columnWidth}                     onResizeStart={onResizeStart}                     onResize={onResize}                     onResizeStop={onResizeStop}                     isComponentVisible={isComponentVisible}                     onChangeTab={onChangeTab}                     isInView={this.state.isInView}                   />                 ))               )}                {dropIndicatorProps && <div {...dropIndicatorProps} />}             </GridRow>           </WithPopoverMenu>         )}       </DragDroppable>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_35_233.js
as_36_236,Inefficient Rendering,"class Tab extends React.PureComponent {   constructor(props) {     super(props);     this.handleChangeText = this.handleChangeText.bind(this);     this.handleDrop = this.handleDrop.bind(this);     this.handleOnHover = this.handleOnHover.bind(this);     this.handleTopDropTargetDrop = this.handleTopDropTargetDrop.bind(this);     this.handleChangeTab = this.handleChangeTab.bind(this);   }    handleChangeTab({ pathToTabIndex }) {     this.props.setDirectPathToChild(pathToTabIndex);   }    handleChangeText(nextTabText) {     const { updateComponents, component } = this.props;     if (nextTabText && nextTabText !== component.meta.text) {       updateComponents({         [component.id]: {           ...component,           meta: {             ...component.meta,             text: nextTabText,           },         },       });     }   }    handleDrop(dropResult) {     this.props.handleComponentDrop(dropResult);     this.props.onDropOnTab(dropResult);   }    handleOnHover() {     this.props.onHoverTab();   }    handleTopDropTargetDrop(dropResult) {     if (dropResult) {       this.props.handleComponentDrop({         ...dropResult,         destination: {           ...dropResult.destination,           // force appending as the first child if top drop target           index: 0,         },       });     }   }    renderTabContent() {     const {       component: tabComponent,       parentComponent: tabParentComponent,       depth,       availableColumnCount,       columnWidth,       onResizeStart,       onResize,       onResizeStop,       editMode,       isComponentVisible,       canEdit,       setEditMode,       dashboardId,     } = this.props;      const shouldDisplayEmptyState = tabComponent.children.length === 0;     return (       <div className=""dashboard-component-tabs-content"">         {/* Make top of tab droppable */}         {editMode && (           <DragDroppable             component={tabComponent}             parentComponent={tabParentComponent}             orientation=""column""             index={0}             depth={depth}             onDrop={this.handleTopDropTargetDrop}             editMode             className=""empty-droptarget""           >             {renderDraggableContentTop}           </DragDroppable>         )}         {shouldDisplayEmptyState && (           <EmptyStateMedium             title={               editMode                 ? t('Drag and drop components to this tab')                 : t('There are no components added to this tab')             }             description={               canEdit &&               (editMode ? (                 <span>                   {t('You can')}{' '}                   <a                     href={`/chart/add?dashboard_id=${dashboardId}`}                     rel=""noopener noreferrer""                     target=""_blank""                   >                     {t('create a new chart')}                   </a>{' '}                   {t('or use existing ones from the panel on the right')}                 </span>               ) : (                 <span>                   {t('You can add the components in the')}{' '}                   <span                     role=""button""                     tabIndex={0}                     onClick={() => setEditMode(true)}                   >                     {t('edit mode')}                   </span>                 </span>               ))             }             image=""chart.svg""           />         )}         {tabComponent.children.map((componentId, componentIndex) => (           <DashboardComponent             key={componentId}             id={componentId}             parentId={tabComponent.id}             depth={depth} // see isValidChild.js for why tabs don't increment child depth             index={componentIndex}             onDrop={this.handleDrop}             onHover={this.handleOnHover}             availableColumnCount={availableColumnCount}             columnWidth={columnWidth}             onResizeStart={onResizeStart}             onResize={onResize}             onResizeStop={onResizeStop}             isComponentVisible={isComponentVisible}             onChangeTab={this.handleChangeTab}           />         ))}         {/* Make bottom of tab droppable */}         {editMode && (           <DragDroppable             component={tabComponent}             parentComponent={tabParentComponent}             orientation=""column""             index={tabComponent.children.length}             depth={depth}             onDrop={this.handleDrop}             onHover={this.handleOnHover}             editMode             className=""empty-droptarget""           >             {renderDraggableContentBottom}           </DragDroppable>         )}       </div>     );   }    renderTab() {     const {       component,       parentComponent,       index,       depth,       editMode,       isFocused,       isHighlighted,     } = this.props;      return (       <DragDroppable         component={component}         parentComponent={parentComponent}         orientation=""column""         index={index}         depth={depth}         onDrop={this.handleDrop}         onHover={this.handleOnHover}         editMode={editMode}       >         {({ dropIndicatorProps, dragSourceRef }) => (           <TabTitleContainer             isHighlighted={isHighlighted}             className=""dragdroppable-tab""             ref={dragSourceRef}           >             <EditableTitle               title={component.meta.text}               defaultTitle={component.meta.defaultText}               placeholder={component.meta.placeholder}               canEdit={editMode && isFocused}               onSaveTitle={this.handleChangeText}               showTooltip={false}               editing={editMode && isFocused}             />             {!editMode && (               <AnchorLink                 id={component.id}                 dashboardId={this.props.dashboardId}                 placement={index >= 5 ? 'left' : 'right'}               />             )}              {dropIndicatorProps && <div {...dropIndicatorProps} />}           </TabTitleContainer>         )}       </DragDroppable>     );   }    render() {     const { renderType } = this.props;     return renderType === RENDER_TAB       ? this.renderTab()       : this.renderTabContent();   } }",C:\Users\Owner\Desktop\DatasetFiles\as_36_236.js
as_37_239,Inefficient Rendering,"export class Tabs extends React.PureComponent {   constructor(props) {     super(props);     const { tabIndex, activeKey } = this.getTabInfo(props);      this.state = {       tabIndex,       activeKey,     };     this.handleClickTab = this.handleClickTab.bind(this);     this.handleDeleteComponent = this.handleDeleteComponent.bind(this);     this.handleDeleteTab = this.handleDeleteTab.bind(this);     this.handleDropOnTab = this.handleDropOnTab.bind(this);     this.handleDrop = this.handleDrop.bind(this);   }    componentDidMount() {     this.props.setActiveTabs(this.state.activeKey);   }    componentDidUpdate(prevProps, prevState) {     if (prevState.activeKey !== this.state.activeKey) {       this.props.setActiveTabs(this.state.activeKey, prevState.activeKey);     }   }    UNSAFE_componentWillReceiveProps(nextProps) {     const maxIndex = Math.max(0, nextProps.component.children.length - 1);     const currTabsIds = this.props.component.children;     const nextTabsIds = nextProps.component.children;      if (this.state.tabIndex > maxIndex) {       this.setState(() => ({ tabIndex: maxIndex }));     }      // reset tab index if dashboard was changed     if (nextProps.dashboardId !== this.props.dashboardId) {       const { tabIndex, activeKey } = this.getTabInfo(nextProps);       this.setState(() => ({         tabIndex,         activeKey,       }));     }      if (nextProps.isComponentVisible) {       const nextFocusComponent = getLeafComponentIdFromPath(         nextProps.directPathToChild,       );       const currentFocusComponent = getLeafComponentIdFromPath(         this.props.directPathToChild,       );        // If the currently selected component is different than the new one,       // or the tab length/order changed, calculate the new tab index and       // replace it if it's different than the current one       if (         nextFocusComponent !== currentFocusComponent ||         (nextFocusComponent === currentFocusComponent &&           currTabsIds !== nextTabsIds)       ) {         const nextTabIndex = findTabIndexByComponentId({           currentComponent: nextProps.component,           directPathToChild: nextProps.directPathToChild,         });          // make sure nextFocusComponent is under this tabs component         if (nextTabIndex > -1 && nextTabIndex !== this.state.tabIndex) {           this.setState(() => ({             tabIndex: nextTabIndex,             activeKey: nextTabsIds[nextTabIndex],           }));         }       }     }   }    getTabInfo = props => {     let tabIndex = Math.max(       0,       findTabIndexByComponentId({         currentComponent: props.component,         directPathToChild: props.directPathToChild,       }),     );     if (tabIndex === 0 && props.activeTabs?.length) {       props.component.children.forEach((tabId, index) => {         if (tabIndex === 0 && props.activeTabs.includes(tabId)) {           tabIndex = index;         }       });     }     const { children: tabIds } = props.component;     const activeKey = tabIds[tabIndex];      return {       tabIndex,       activeKey,     };   };    showDeleteConfirmModal = key => {     const { component, deleteComponent } = this.props;     AntdModal.confirm({       title: t('Delete dashboard tab?'),       content: (         <span>           {t(             'Deleting a tab will remove all content within it. You may still ' +               'reverse this action with the',           )}{' '}           <b>{t('undo')}</b>{' '}           {t('button (cmd + z) until you save your changes.')}         </span>       ),       onOk: () => {         deleteComponent(key, component.id);         const tabIndex = component.children.indexOf(key);         this.handleDeleteTab(tabIndex);       },       okType: 'danger',       okText: t('DELETE'),       cancelText: t('CANCEL'),       icon: null,     });   };    handleEdit = (event, action) => {     const { component, createComponent } = this.props;     if (action === 'add') {       // Prevent the tab container to be selected       event?.stopPropagation?.();        createComponent({         destination: {           id: component.id,           type: component.type,           index: component.children.length,         },         dragging: {           id: NEW_TAB_ID,           type: TAB_TYPE,         },       });     } else if (action === 'remove') {       this.showDeleteConfirmModal(event);     }   };    handleClickTab(tabIndex) {     const { component } = this.props;     const { children: tabIds } = component;      if (tabIndex !== this.state.tabIndex) {       const pathToTabIndex = getDirectPathToTabIndex(component, tabIndex);       const targetTabId = pathToTabIndex[pathToTabIndex.length - 1];       this.props.logEvent(LOG_ACTIONS_SELECT_DASHBOARD_TAB, {         target_id: targetTabId,         index: tabIndex,       });        this.props.onChangeTab({ pathToTabIndex });     }     this.setState(() => ({ activeKey: tabIds[tabIndex] }));   }    handleDeleteComponent() {     const { deleteComponent, id, parentId } = this.props;     deleteComponent(id, parentId);   }    handleDeleteTab(tabIndex) {     // If we're removing the currently selected tab,     // select the previous one (if any)     if (this.state.tabIndex === tabIndex) {       this.handleClickTab(Math.max(0, tabIndex - 1));     }   }    handleDropOnTab(dropResult) {     const { component } = this.props;      // Ensure dropped tab is visible     const { destination } = dropResult;     if (destination) {       const dropTabIndex =         destination.id === component.id           ? destination.index // dropped ON tabs           : component.children.indexOf(destination.id); // dropped IN tab        if (dropTabIndex > -1) {         setTimeout(() => {           this.handleClickTab(dropTabIndex);         }, 30);       }     }   }    handleDrop(dropResult) {     if (dropResult.dragging.type !== TABS_TYPE) {       this.props.handleComponentDrop(dropResult);     }   }    render() {     const {       depth,       component: tabsComponent,       parentComponent,       index,       availableColumnCount,       columnWidth,       onResizeStart,       onResize,       onResizeStop,       renderTabContent,       renderHoverMenu,       isComponentVisible: isCurrentTabVisible,       editMode,       nativeFilters,     } = this.props;      const { children: tabIds } = tabsComponent;     const { tabIndex: selectedTabIndex, activeKey } = this.state;      let tabsToHighlight;     const highlightedFilterId =       nativeFilters?.focusedFilterId || nativeFilters?.hoveredFilterId;     if (highlightedFilterId) {       tabsToHighlight = nativeFilters.filters[highlightedFilterId]?.tabsInScope;     }     return (       <DragDroppable         component={tabsComponent}         parentComponent={parentComponent}         orientation=""row""         index={index}         depth={depth}         onDrop={this.handleDrop}         editMode={editMode}       >         {({           dropIndicatorProps: tabsDropIndicatorProps,           dragSourceRef: tabsDragSourceRef,         }) => (           <StyledTabsContainer             className=""dashboard-component dashboard-component-tabs""             data-test=""dashboard-component-tabs""           >             {editMode && renderHoverMenu && (               <HoverMenu innerRef={tabsDragSourceRef} position=""left"">                 <DragHandle position=""left"" />                 <DeleteComponentButton onDelete={this.handleDeleteComponent} />               </HoverMenu>             )}              <LineEditableTabs               id={tabsComponent.id}               activeKey={activeKey}               onChange={key => {                 this.handleClickTab(tabIds.indexOf(key));               }}               onEdit={this.handleEdit}               data-test=""nav-list""               type={editMode ? 'editable-card' : 'card'}             >               {tabIds.map((tabId, tabIndex) => (                 <LineEditableTabs.TabPane                   key={tabId}                   tab={                     <DashboardComponent                       id={tabId}                       parentId={tabsComponent.id}                       depth={depth}                       index={tabIndex}                       renderType={RENDER_TAB}                       availableColumnCount={availableColumnCount}                       columnWidth={columnWidth}                       onDropOnTab={this.handleDropOnTab}                       onHoverTab={() => this.handleClickTab(tabIndex)}                       isFocused={activeKey === tabId}                       isHighlighted={                         activeKey !== tabId && tabsToHighlight?.includes(tabId)                       }                     />                   }                 >                   {renderTabContent && (                     <DashboardComponent                       id={tabId}                       parentId={tabsComponent.id}                       depth={depth} // see isValidChild.js for why tabs don't increment child depth                       index={tabIndex}                       renderType={RENDER_TAB_CONTENT}                       availableColumnCount={availableColumnCount}                       columnWidth={columnWidth}                       onResizeStart={onResizeStart}                       onResize={onResize}                       onResizeStop={onResizeStop}                       onDropOnTab={this.handleDropOnTab}                       isComponentVisible={                         selectedTabIndex === tabIndex && isCurrentTabVisible                       }                     />                   )}                 </LineEditableTabs.TabPane>               ))}             </LineEditableTabs>              {/* don't indicate that a drop on root is allowed when tabs already exist */}             {tabsDropIndicatorProps &&               parentComponent.id !== DASHBOARD_ROOT_ID && (                 <div {...tabsDropIndicatorProps} />               )}           </StyledTabsContainer>         )}       </DragDroppable>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_37_239.js
as_38_243,Inefficient Rendering,"class HeaderActionsDropdown extends React.PureComponent {   static discardChanges() {     window.location.reload();   }    constructor(props) {     super(props);     this.state = {       css: props.customCss,       cssTemplates: [],       showReportSubMenu: null,     };      this.changeCss = this.changeCss.bind(this);     this.changeRefreshInterval = this.changeRefreshInterval.bind(this);     this.handleMenuClick = this.handleMenuClick.bind(this);     this.setShowReportSubMenu = this.setShowReportSubMenu.bind(this);   }    UNSAFE_componentWillMount() {     SupersetClient.get({ endpoint: '/csstemplateasyncmodelview/api/read' })       .then(({ json }) => {         const cssTemplates = json.result.map(row => ({           value: row.template_name,           css: row.css,           label: row.template_name,         }));         this.setState({ cssTemplates });       })       .catch(() => {         this.props.addDangerToast(           t('An error occurred while fetching available CSS templates'),         );       });   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (this.props.customCss !== nextProps.customCss) {       this.setState({ css: nextProps.customCss }, () => {         injectCustomCss(nextProps.customCss);       });     }   }    setShowReportSubMenu(show) {     this.setState({       showReportSubMenu: show,     });   }    changeCss(css) {     this.props.onChange();     this.props.updateCss(css);   }    changeRefreshInterval(refreshInterval, isPersistent) {     this.props.setRefreshFrequency(refreshInterval, isPersistent);     this.props.startPeriodicRender(refreshInterval * 1000);   }    handleMenuClick({ key, domEvent }) {     switch (key) {       case MENU_KEYS.REFRESH_DASHBOARD:         this.props.forceRefreshAllCharts();         this.props.addSuccessToast(t('Refreshing charts'));         break;       case MENU_KEYS.EDIT_PROPERTIES:         this.props.showPropertiesModal();         break;       case MENU_KEYS.DOWNLOAD_AS_IMAGE: {         // menu closes with a delay, we need to hide it manually,         // so that we don't capture it on the screenshot         const menu = document.querySelector(           '.ant-dropdown:not(.ant-dropdown-hidden)',         );         menu.style.visibility = 'hidden';         downloadAsImage(           SCREENSHOT_NODE_SELECTOR,           this.props.dashboardTitle,           true,         )(domEvent).then(() => {           menu.style.visibility = 'visible';         });         this.props.logEvent?.(LOG_ACTIONS_DASHBOARD_DOWNLOAD_AS_IMAGE);         break;       }       case MENU_KEYS.TOGGLE_FULLSCREEN: {         const url = getDashboardUrl({           pathname: window.location.pathname,           filters: getActiveFilters(),           hash: window.location.hash,           standalone: !getUrlParam(URL_PARAMS.standalone),         });         window.location.replace(url);         break;       }       case MENU_KEYS.MANAGE_EMBEDDED: {         this.props.manageEmbedded();         break;       }       default:         break;     }   }    render() {     const {       dashboardTitle,       dashboardId,       dashboardInfo,       refreshFrequency,       shouldPersistRefreshFrequency,       editMode,       customCss,       colorNamespace,       colorScheme,       layout,       expandedSlices,       onSave,       userCanEdit,       userCanShare,       userCanSave,       userCanCurate,       isLoading,       refreshLimit,       refreshWarning,       lastModifiedTime,       addSuccessToast,       addDangerToast,       setIsDropdownVisible,       isDropdownVisible,       ...rest     } = this.props;      const emailTitle = t('Superset dashboard');     const emailSubject = `${emailTitle} ${dashboardTitle}`;     const emailBody = t('Check out this dashboard: ');      const url = getDashboardUrl({       pathname: window.location.pathname,       filters: getActiveFilters(),       hash: window.location.hash,     });      const refreshIntervalOptions =       dashboardInfo.common?.conf?.DASHBOARD_AUTO_REFRESH_INTERVALS;      return (       <Menu selectable={false} data-test=""header-actions-menu"" {...rest}>         {!editMode && (           <Menu.Item             key={MENU_KEYS.REFRESH_DASHBOARD}             data-test=""refresh-dashboard-menu-item""             disabled={isLoading}             onClick={this.handleMenuClick}           >             {t('Refresh dashboard')}           </Menu.Item>         )}         {!editMode && (           <Menu.Item             key={MENU_KEYS.TOGGLE_FULLSCREEN}             onClick={this.handleMenuClick}           >             {getUrlParam(URL_PARAMS.standalone)               ? t('Exit fullscreen')               : t('Enter fullscreen')}           </Menu.Item>         )}         {editMode && (           <Menu.Item             key={MENU_KEYS.EDIT_PROPERTIES}             onClick={this.handleMenuClick}           >             {t('Edit properties')}           </Menu.Item>         )}         {editMode && (           <Menu.Item key={MENU_KEYS.EDIT_CSS}>             <CssEditor               triggerNode={<span>{t('Edit CSS')}</span>}               initialCss={this.state.css}               templates={this.state.cssTemplates}               onChange={this.changeCss}             />           </Menu.Item>         )}         <Menu.Divider />         {userCanSave && (           <Menu.Item key={MENU_KEYS.SAVE_MODAL}>             <SaveModal               addSuccessToast={this.props.addSuccessToast}               addDangerToast={this.props.addDangerToast}               dashboardId={dashboardId}               dashboardTitle={dashboardTitle}               dashboardInfo={dashboardInfo}               saveType={SAVE_TYPE_NEWDASHBOARD}               layout={layout}               expandedSlices={expandedSlices}               refreshFrequency={refreshFrequency}               shouldPersistRefreshFrequency={shouldPersistRefreshFrequency}               lastModifiedTime={lastModifiedTime}               customCss={customCss}               colorNamespace={colorNamespace}               colorScheme={colorScheme}               onSave={onSave}               triggerNode={                 <span data-test=""save-as-menu-item"">{t('Save as')}</span>               }               canOverwrite={userCanEdit}             />           </Menu.Item>         )}         {!editMode && (           <Menu.Item             key={MENU_KEYS.DOWNLOAD_AS_IMAGE}             onClick={this.handleMenuClick}           >             {t('Download as image')}           </Menu.Item>         )}         {userCanShare && (           <Menu.SubMenu             key={MENU_KEYS.SHARE_DASHBOARD}             data-test=""share-dashboard-menu-item""             disabled={isLoading}             title={t('Share')}           >             <ShareMenuItems               url={url}               copyMenuItemTitle={t('Copy permalink to clipboard')}               emailMenuItemTitle={t('Share permalink by email')}               emailSubject={emailSubject}               emailBody={emailBody}               addSuccessToast={addSuccessToast}               addDangerToast={addDangerToast}               dashboardId={dashboardId}             />           </Menu.SubMenu>         )}         {!editMode && userCanCurate && (           <Menu.Item             key={MENU_KEYS.MANAGE_EMBEDDED}             onClick={this.handleMenuClick}           >             {t('Embed dashboard')}           </Menu.Item>         )}         <Menu.Divider />         {!editMode ? (           this.state.showReportSubMenu ? (             <>               <Menu.SubMenu title={t('Manage email report')}>                 <HeaderReportDropdown                   dashboardId={dashboardInfo.id}                   setShowReportSubMenu={this.setShowReportSubMenu}                   showReportSubMenu={this.state.showReportSubMenu}                   setIsDropdownVisible={setIsDropdownVisible}                   isDropdownVisible={isDropdownVisible}                   useTextMenu                 />               </Menu.SubMenu>               <Menu.Divider />             </>           ) : (             <Menu>               <HeaderReportDropdown                 dashboardId={dashboardInfo.id}                 setShowReportSubMenu={this.setShowReportSubMenu}                 setIsDropdownVisible={setIsDropdownVisible}                 isDropdownVisible={isDropdownVisible}                 useTextMenu               />             </Menu>           )         ) : null}         {editMode &&           !(             isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) &&             isEmpty(dashboardInfo?.metadata?.filter_scopes)           ) && (             <Menu.Item key={MENU_KEYS.SET_FILTER_MAPPING}>               <FilterScopeModal                 className=""m-r-5""                 triggerNode={t('Set filter mapping')}               />             </Menu.Item>           )}          <Menu.Item key={MENU_KEYS.AUTOREFRESH_MODAL}>           <RefreshIntervalModal             addSuccessToast={this.props.addSuccessToast}             refreshFrequency={refreshFrequency}             refreshLimit={refreshLimit}             refreshWarning={refreshWarning}             onChange={this.changeRefreshInterval}             editMode={editMode}             refreshIntervalOptions={refreshIntervalOptions}             triggerNode={<span>{t('Set auto-refresh interval')}</span>}           />         </Menu.Item>       </Menu>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_38_243.js
as_39_244,Props in initial state,"class HeaderActionsDropdown extends React.PureComponent {   static discardChanges() {     window.location.reload();   }    constructor(props) {     super(props);     this.state = {       css: props.customCss,       cssTemplates: [],       showReportSubMenu: null,     };      this.changeCss = this.changeCss.bind(this);     this.changeRefreshInterval = this.changeRefreshInterval.bind(this);     this.handleMenuClick = this.handleMenuClick.bind(this);     this.setShowReportSubMenu = this.setShowReportSubMenu.bind(this);   }    UNSAFE_componentWillMount() {     SupersetClient.get({ endpoint: '/csstemplateasyncmodelview/api/read' })       .then(({ json }) => {         const cssTemplates = json.result.map(row => ({           value: row.template_name,           css: row.css,           label: row.template_name,         }));         this.setState({ cssTemplates });       })       .catch(() => {         this.props.addDangerToast(           t('An error occurred while fetching available CSS templates'),         );       });   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (this.props.customCss !== nextProps.customCss) {       this.setState({ css: nextProps.customCss }, () => {         injectCustomCss(nextProps.customCss);       });     }   }    setShowReportSubMenu(show) {     this.setState({       showReportSubMenu: show,     });   }    changeCss(css) {     this.props.onChange();     this.props.updateCss(css);   }    changeRefreshInterval(refreshInterval, isPersistent) {     this.props.setRefreshFrequency(refreshInterval, isPersistent);     this.props.startPeriodicRender(refreshInterval * 1000);   }    handleMenuClick({ key, domEvent }) {     switch (key) {       case MENU_KEYS.REFRESH_DASHBOARD:         this.props.forceRefreshAllCharts();         this.props.addSuccessToast(t('Refreshing charts'));         break;       case MENU_KEYS.EDIT_PROPERTIES:         this.props.showPropertiesModal();         break;       case MENU_KEYS.DOWNLOAD_AS_IMAGE: {         // menu closes with a delay, we need to hide it manually,         // so that we don't capture it on the screenshot         const menu = document.querySelector(           '.ant-dropdown:not(.ant-dropdown-hidden)',         );         menu.style.visibility = 'hidden';         downloadAsImage(           SCREENSHOT_NODE_SELECTOR,           this.props.dashboardTitle,           true,         )(domEvent).then(() => {           menu.style.visibility = 'visible';         });         this.props.logEvent?.(LOG_ACTIONS_DASHBOARD_DOWNLOAD_AS_IMAGE);         break;       }       case MENU_KEYS.TOGGLE_FULLSCREEN: {         const url = getDashboardUrl({           pathname: window.location.pathname,           filters: getActiveFilters(),           hash: window.location.hash,           standalone: !getUrlParam(URL_PARAMS.standalone),         });         window.location.replace(url);         break;       }       case MENU_KEYS.MANAGE_EMBEDDED: {         this.props.manageEmbedded();         break;       }       default:         break;     }   }    render() {     const {       dashboardTitle,       dashboardId,       dashboardInfo,       refreshFrequency,       shouldPersistRefreshFrequency,       editMode,       customCss,       colorNamespace,       colorScheme,       layout,       expandedSlices,       onSave,       userCanEdit,       userCanShare,       userCanSave,       userCanCurate,       isLoading,       refreshLimit,       refreshWarning,       lastModifiedTime,       addSuccessToast,       addDangerToast,       setIsDropdownVisible,       isDropdownVisible,       ...rest     } = this.props;      const emailTitle = t('Superset dashboard');     const emailSubject = `${emailTitle} ${dashboardTitle}`;     const emailBody = t('Check out this dashboard: ');      const url = getDashboardUrl({       pathname: window.location.pathname,       filters: getActiveFilters(),       hash: window.location.hash,     });      const refreshIntervalOptions =       dashboardInfo.common?.conf?.DASHBOARD_AUTO_REFRESH_INTERVALS;      return (       <Menu selectable={false} data-test=""header-actions-menu"" {...rest}>         {!editMode && (           <Menu.Item             key={MENU_KEYS.REFRESH_DASHBOARD}             data-test=""refresh-dashboard-menu-item""             disabled={isLoading}             onClick={this.handleMenuClick}           >             {t('Refresh dashboard')}           </Menu.Item>         )}         {!editMode && (           <Menu.Item             key={MENU_KEYS.TOGGLE_FULLSCREEN}             onClick={this.handleMenuClick}           >             {getUrlParam(URL_PARAMS.standalone)               ? t('Exit fullscreen')               : t('Enter fullscreen')}           </Menu.Item>         )}         {editMode && (           <Menu.Item             key={MENU_KEYS.EDIT_PROPERTIES}             onClick={this.handleMenuClick}           >             {t('Edit properties')}           </Menu.Item>         )}         {editMode && (           <Menu.Item key={MENU_KEYS.EDIT_CSS}>             <CssEditor               triggerNode={<span>{t('Edit CSS')}</span>}               initialCss={this.state.css}               templates={this.state.cssTemplates}               onChange={this.changeCss}             />           </Menu.Item>         )}         <Menu.Divider />         {userCanSave && (           <Menu.Item key={MENU_KEYS.SAVE_MODAL}>             <SaveModal               addSuccessToast={this.props.addSuccessToast}               addDangerToast={this.props.addDangerToast}               dashboardId={dashboardId}               dashboardTitle={dashboardTitle}               dashboardInfo={dashboardInfo}               saveType={SAVE_TYPE_NEWDASHBOARD}               layout={layout}               expandedSlices={expandedSlices}               refreshFrequency={refreshFrequency}               shouldPersistRefreshFrequency={shouldPersistRefreshFrequency}               lastModifiedTime={lastModifiedTime}               customCss={customCss}               colorNamespace={colorNamespace}               colorScheme={colorScheme}               onSave={onSave}               triggerNode={                 <span data-test=""save-as-menu-item"">{t('Save as')}</span>               }               canOverwrite={userCanEdit}             />           </Menu.Item>         )}         {!editMode && (           <Menu.Item             key={MENU_KEYS.DOWNLOAD_AS_IMAGE}             onClick={this.handleMenuClick}           >             {t('Download as image')}           </Menu.Item>         )}         {userCanShare && (           <Menu.SubMenu             key={MENU_KEYS.SHARE_DASHBOARD}             data-test=""share-dashboard-menu-item""             disabled={isLoading}             title={t('Share')}           >             <ShareMenuItems               url={url}               copyMenuItemTitle={t('Copy permalink to clipboard')}               emailMenuItemTitle={t('Share permalink by email')}               emailSubject={emailSubject}               emailBody={emailBody}               addSuccessToast={addSuccessToast}               addDangerToast={addDangerToast}               dashboardId={dashboardId}             />           </Menu.SubMenu>         )}         {!editMode && userCanCurate && (           <Menu.Item             key={MENU_KEYS.MANAGE_EMBEDDED}             onClick={this.handleMenuClick}           >             {t('Embed dashboard')}           </Menu.Item>         )}         <Menu.Divider />         {!editMode ? (           this.state.showReportSubMenu ? (             <>               <Menu.SubMenu title={t('Manage email report')}>                 <HeaderReportDropdown                   dashboardId={dashboardInfo.id}                   setShowReportSubMenu={this.setShowReportSubMenu}                   showReportSubMenu={this.state.showReportSubMenu}                   setIsDropdownVisible={setIsDropdownVisible}                   isDropdownVisible={isDropdownVisible}                   useTextMenu                 />               </Menu.SubMenu>               <Menu.Divider />             </>           ) : (             <Menu>               <HeaderReportDropdown                 dashboardId={dashboardInfo.id}                 setShowReportSubMenu={this.setShowReportSubMenu}                 setIsDropdownVisible={setIsDropdownVisible}                 isDropdownVisible={isDropdownVisible}                 useTextMenu               />             </Menu>           )         ) : null}         {editMode &&           !(             isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) &&             isEmpty(dashboardInfo?.metadata?.filter_scopes)           ) && (             <Menu.Item key={MENU_KEYS.SET_FILTER_MAPPING}>               <FilterScopeModal                 className=""m-r-5""                 triggerNode={t('Set filter mapping')}               />             </Menu.Item>           )}          <Menu.Item key={MENU_KEYS.AUTOREFRESH_MODAL}>           <RefreshIntervalModal             addSuccessToast={this.props.addSuccessToast}             refreshFrequency={refreshFrequency}             refreshLimit={refreshLimit}             refreshWarning={refreshWarning}             onChange={this.changeRefreshInterval}             editMode={editMode}             refreshIntervalOptions={refreshIntervalOptions}             triggerNode={<span>{t('Set auto-refresh interval')}</span>}           />         </Menu.Item>       </Menu>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_39_244.js
as_40_247,Inefficient Rendering,"class Header extends React.PureComponent {   static discardChanges() {     const url = new URL(window.location.href);      url.searchParams.delete('edit');     window.location.assign(url);   }    constructor(props) {     super(props);     this.state = {       didNotifyMaxUndoHistoryToast: false,       emphasizeUndo: false,       emphasizeRedo: false,       showingPropertiesModal: false,       isDropdownVisible: false,     };      this.handleChangeText = this.handleChangeText.bind(this);     this.handleCtrlZ = this.handleCtrlZ.bind(this);     this.handleCtrlY = this.handleCtrlY.bind(this);     this.toggleEditMode = this.toggleEditMode.bind(this);     this.forceRefresh = this.forceRefresh.bind(this);     this.startPeriodicRender = this.startPeriodicRender.bind(this);     this.overwriteDashboard = this.overwriteDashboard.bind(this);     this.showPropertiesModal = this.showPropertiesModal.bind(this);     this.hidePropertiesModal = this.hidePropertiesModal.bind(this);     this.setIsDropdownVisible = this.setIsDropdownVisible.bind(this);   }    componentDidMount() {     const { refreshFrequency } = this.props;     this.startPeriodicRender(refreshFrequency * 1000);   }    componentDidUpdate(prevProps) {     if (this.props.refreshFrequency !== prevProps.refreshFrequency) {       const { refreshFrequency } = this.props;       this.startPeriodicRender(refreshFrequency * 1000);     }   }    UNSAFE_componentWillReceiveProps(nextProps) {     if (       UNDO_LIMIT - nextProps.undoLength <= 0 &&       !this.state.didNotifyMaxUndoHistoryToast     ) {       this.setState(() => ({ didNotifyMaxUndoHistoryToast: true }));       this.props.maxUndoHistoryToast();     }     if (       nextProps.undoLength > UNDO_LIMIT &&       !this.props.maxUndoHistoryExceeded     ) {       this.props.setMaxUndoHistoryExceeded();     }   }    componentWillUnmount() {     stopPeriodicRender(this.refreshTimer);     this.props.setRefreshFrequency(0);     clearTimeout(this.ctrlYTimeout);     clearTimeout(this.ctrlZTimeout);   }    handleChangeText(nextText) {     const { updateDashboardTitle, onChange } = this.props;     if (nextText && this.props.dashboardTitle !== nextText) {       updateDashboardTitle(nextText);       onChange();     }   }    setIsDropdownVisible(visible) {     this.setState({       isDropdownVisible: visible,     });   }    handleCtrlY() {     this.props.onRedo();     this.setState({ emphasizeRedo: true }, () => {       if (this.ctrlYTimeout) clearTimeout(this.ctrlYTimeout);       this.ctrlYTimeout = setTimeout(() => {         this.setState({ emphasizeRedo: false });       }, 100);     });   }    handleCtrlZ() {     this.props.onUndo();     this.setState({ emphasizeUndo: true }, () => {       if (this.ctrlZTimeout) clearTimeout(this.ctrlZTimeout);       this.ctrlZTimeout = setTimeout(() => {         this.setState({ emphasizeUndo: false });       }, 100);     });   }    forceRefresh() {     if (!this.props.isLoading) {       const chartList = Object.keys(this.props.charts);       this.props.logEvent(LOG_ACTIONS_FORCE_REFRESH_DASHBOARD, {         force: true,         interval: 0,         chartCount: chartList.length,       });       return this.props.onRefresh(         chartList,         true,         0,         this.props.dashboardInfo.id,       );     }     return false;   }    startPeriodicRender(interval) {     let intervalMessage;      if (interval) {       const { dashboardInfo } = this.props;       const periodicRefreshOptions =         dashboardInfo.common?.conf?.DASHBOARD_AUTO_REFRESH_INTERVALS;       const predefinedValue = periodicRefreshOptions.find(         option => Number(option[0]) === interval / 1000,       );        if (predefinedValue) {         intervalMessage = t(predefinedValue[1]);       } else {         intervalMessage = moment.duration(interval, 'millisecond').humanize();       }     }      const periodicRender = () => {       const { fetchCharts, logEvent, charts, dashboardInfo } = this.props;       const { metadata } = dashboardInfo;       const immune = metadata.timed_refresh_immune_slices || [];       const affectedCharts = Object.values(charts)         .filter(chart => immune.indexOf(chart.id) === -1)         .map(chart => chart.id);        logEvent(LOG_ACTIONS_PERIODIC_RENDER_DASHBOARD, {         interval,         chartCount: affectedCharts.length,       });       this.props.addWarningToast(         t(           `This dashboard is currently auto refreshing; the next auto refresh will be in %s.`,           intervalMessage,         ),       );       if (dashboardInfo.common.conf.DASHBOARD_AUTO_REFRESH_MODE === 'fetch') {         // force-refresh while auto-refresh in dashboard         return fetchCharts(           affectedCharts,           false,           interval * 0.2,           dashboardInfo.id,         );       }       return fetchCharts(         affectedCharts,         true,         interval * 0.2,         dashboardInfo.id,       );     };      this.refreshTimer = setPeriodicRunner({       interval,       periodicRender,       refreshTimer: this.refreshTimer,     });   }    toggleEditMode() {     this.props.logEvent(LOG_ACTIONS_TOGGLE_EDIT_DASHBOARD, {       edit_mode: !this.props.editMode,     });     this.props.setEditMode(!this.props.editMode);   }    overwriteDashboard() {     const {       dashboardTitle,       layout: positions,       colorScheme,       colorNamespace,       customCss,       dashboardInfo,       refreshFrequency: currentRefreshFrequency,       shouldPersistRefreshFrequency,       lastModifiedTime,       slug,     } = this.props;      // check refresh frequency is for current session or persist     const refreshFrequency = shouldPersistRefreshFrequency       ? currentRefreshFrequency       : dashboardInfo.metadata?.refresh_frequency;      const currentColorScheme =       dashboardInfo?.metadata?.color_scheme || colorScheme;     const currentColorNamespace =       dashboardInfo?.metadata?.color_namespace || colorNamespace;     const currentSharedLabelColors = Object.fromEntries(       getSharedLabelColor().getColorMap(),     );      const data = {       certified_by: dashboardInfo.certified_by,       certification_details: dashboardInfo.certification_details,       css: customCss,       dashboard_title: dashboardTitle,       last_modified_time: lastModifiedTime,       owners: dashboardInfo.owners,       roles: dashboardInfo.roles,       slug,       metadata: {         ...dashboardInfo?.metadata,         color_namespace: currentColorNamespace,         color_scheme: currentColorScheme,         positions,         refresh_frequency: refreshFrequency,         shared_label_colors: currentSharedLabelColors,       },     };      // make sure positions data less than DB storage limitation:     const positionJSONLength = safeStringify(positions).length;     const limit =       dashboardInfo.common.conf.SUPERSET_DASHBOARD_POSITION_DATA_LIMIT ||       DASHBOARD_POSITION_DATA_LIMIT;     if (positionJSONLength >= limit) {       this.props.addDangerToast(         t(           'Your dashboard is too large. Please reduce its size before saving it.',         ),       );     } else {       if (positionJSONLength >= limit * 0.9) {         this.props.addWarningToast('Your dashboard is near the size limit.');       }        this.props.onSave(data, dashboardInfo.id, SAVE_TYPE_OVERWRITE);     }   }    showPropertiesModal() {     this.setState({ showingPropertiesModal: true });   }    hidePropertiesModal() {     this.setState({ showingPropertiesModal: false });   }    showEmbedModal = () => {     this.setState({ showingEmbedModal: true });   };    hideEmbedModal = () => {     this.setState({ showingEmbedModal: false });   };    render() {     const {       dashboardTitle,       layout,       expandedSlices,       customCss,       colorNamespace,       dataMask,       setColorScheme,       setUnsavedChanges,       colorScheme,       onUndo,       onRedo,       undoLength,       redoLength,       onChange,       onSave,       updateCss,       editMode,       isPublished,       user,       dashboardInfo,       hasUnsavedChanges,       isLoading,       refreshFrequency,       shouldPersistRefreshFrequency,       setRefreshFrequency,       lastModifiedTime,       logEvent,     } = this.props;      const userCanEdit =       dashboardInfo.dash_edit_perm && !dashboardInfo.is_managed_externally;     const userCanShare = dashboardInfo.dash_share_perm;     const userCanSaveAs = dashboardInfo.dash_save_perm;     const userCanCurate =       isFeatureEnabled(FeatureFlag.EMBEDDED_SUPERSET) &&       findPermission('can_set_embedded', 'Dashboard', user.roles);     const refreshLimit =       dashboardInfo.common?.conf?.SUPERSET_DASHBOARD_PERIODICAL_REFRESH_LIMIT;     const refreshWarning =       dashboardInfo.common?.conf         ?.SUPERSET_DASHBOARD_PERIODICAL_REFRESH_WARNING_MESSAGE;      const handleOnPropertiesChange = updates => {       const { dashboardInfoChanged, dashboardTitleChanged } = this.props;        setColorScheme(updates.colorScheme);       dashboardInfoChanged({         slug: updates.slug,         metadata: JSON.parse(updates.jsonMetadata || '{}'),         certified_by: updates.certifiedBy,         certification_details: updates.certificationDetails,         owners: updates.owners,         roles: updates.roles,       });       setUnsavedChanges(true);       dashboardTitleChanged(updates.title);     };      const NavExtension = uiOverrideRegistry.get('dashboard.nav.right');      return (       <div         css={headerContainerStyle}         data-test=""dashboard-header-container""         data-test-id={dashboardInfo.id}         className=""dashboard-header-container""       >         <PageHeaderWithActions           editableTitleProps={{             title: dashboardTitle,             canEdit: userCanEdit && editMode,             onSave: this.handleChangeText,             placeholder: t('Add the name of the dashboard'),             label: t('Dashboard title'),             showTooltip: false,           }}           certificatiedBadgeProps={{             certifiedBy: dashboardInfo.certified_by,             details: dashboardInfo.certification_details,           }}           faveStarProps={{             itemId: dashboardInfo.id,             fetchFaveStar: this.props.fetchFaveStar,             saveFaveStar: this.props.saveFaveStar,             isStarred: this.props.isStarred,             showTooltip: true,           }}           titlePanelAdditionalItems={[             !editMode && (               <PublishedStatus                 dashboardId={dashboardInfo.id}                 isPublished={isPublished}                 savePublished={this.props.savePublished}                 canEdit={userCanEdit}                 canSave={userCanSaveAs}                 visible={!editMode}               />             ),           ]}           rightPanelAdditionalItems={             <div className=""button-container"">               {userCanSaveAs && (                 <div                   className=""button-container""                   data-test=""dashboard-edit-actions""                 >                   {editMode && (                     <div css={actionButtonsStyle}>                       <div className=""undoRedo"">                         <Tooltip                           id=""dashboard-undo-tooltip""                           title={t('Undo the action')}                         >                           <StyledUndoRedoButton                             type=""text""                             disabled={undoLength < 1}                           >                             <Icons.Undo                               css={[                                 undoRedoStyle,                                 this.state.emphasizeUndo && undoRedoEmphasized,                                 undoLength < 1 && undoRedoDisabled,                               ]}                               onClick={undoLength && onUndo}                               data-test=""undo-action""                               iconSize=""xl""                             />                           </StyledUndoRedoButton>                         </Tooltip>                         <Tooltip                           id=""dashboard-redo-tooltip""                           title={t('Redo the action')}                         >                           <StyledUndoRedoButton                             type=""text""                             disabled={redoLength < 1}                           >                             <Icons.Redo                               css={[                                 undoRedoStyle,                                 this.state.emphasizeRedo && undoRedoEmphasized,                                 redoLength < 1 && undoRedoDisabled,                               ]}                               onClick={redoLength && onRedo}                               data-test=""redo-action""                               iconSize=""xl""                             />                           </StyledUndoRedoButton>                         </Tooltip>                       </div>                       <Button                         css={discardBtnStyle}                         buttonSize=""small""                         onClick={this.constructor.discardChanges}                         buttonStyle=""default""                         data-test=""discard-changes-button""                         aria-label={t('Discard')}                       >                         {t('Discard')}                       </Button>                       <Button                         css={saveBtnStyle}                         buttonSize=""small""                         disabled={!hasUnsavedChanges}                         buttonStyle=""primary""                         onClick={this.overwriteDashboard}                         data-test=""header-save-button""                         aria-label={t('Save')}                       >                         {t('Save')}                       </Button>                     </div>                   )}                 </div>               )}               {editMode ? (                 <UndoRedoKeyListeners                   onUndo={this.handleCtrlZ}                   onRedo={this.handleCtrlY}                 />               ) : (                 <div css={actionButtonsStyle}>                   {NavExtension && <NavExtension />}                   {userCanEdit && (                     <Button                       buttonStyle=""secondary""                       onClick={this.toggleEditMode}                       data-test=""edit-dashboard-button""                       className=""action-button""                       css={editButtonStyle}                       aria-label={t('Edit dashboard')}                     >                       {t('Edit dashboard')}                     </Button>                   )}                 </div>               )}             </div>           }           menuDropdownProps={{             getPopupContainer: triggerNode =>               triggerNode.closest('.header-with-actions'),             visible: this.state.isDropdownVisible,             onVisibleChange: this.setIsDropdownVisible,           }}           additionalActionsMenu={             <HeaderActionsDropdown               addSuccessToast={this.props.addSuccessToast}               addDangerToast={this.props.addDangerToast}               dashboardId={dashboardInfo.id}               dashboardTitle={dashboardTitle}               dashboardInfo={dashboardInfo}               dataMask={dataMask}               layout={layout}               expandedSlices={expandedSlices}               customCss={customCss}               colorNamespace={colorNamespace}               colorScheme={colorScheme}               onSave={onSave}               onChange={onChange}               forceRefreshAllCharts={this.forceRefresh}               startPeriodicRender={this.startPeriodicRender}               refreshFrequency={refreshFrequency}               shouldPersistRefreshFrequency={shouldPersistRefreshFrequency}               setRefreshFrequency={setRefreshFrequency}               updateCss={updateCss}               editMode={editMode}               hasUnsavedChanges={hasUnsavedChanges}               userCanEdit={userCanEdit}               userCanShare={userCanShare}               userCanSave={userCanSaveAs}               userCanCurate={userCanCurate}               isLoading={isLoading}               showPropertiesModal={this.showPropertiesModal}               manageEmbedded={this.showEmbedModal}               refreshLimit={refreshLimit}               refreshWarning={refreshWarning}               lastModifiedTime={lastModifiedTime}               isDropdownVisible={this.state.isDropdownVisible}               setIsDropdownVisible={this.setIsDropdownVisible}               logEvent={logEvent}             />           }           showFaveStar={user?.userId && dashboardInfo?.id}           showTitlePanelItems         />         {this.state.showingPropertiesModal && (           <PropertiesModal             dashboardId={dashboardInfo.id}             dashboardInfo={dashboardInfo}             dashboardTitle={dashboardTitle}             show={this.state.showingPropertiesModal}             onHide={this.hidePropertiesModal}             colorScheme={this.props.colorScheme}             onSubmit={handleOnPropertiesChange}             onlyApply           />         )}          <OverwriteConfirm />          {userCanCurate && (           <DashboardEmbedModal             show={this.state.showingEmbedModal}             onHide={this.hideEmbedModal}             dashboardId={dashboardInfo.id}           />         )}         <Global           styles={css`             .ant-menu-vertical {               border-right: none;             }           `}         />       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_40_247.js
as_41_248,Inefficient Rendering,"export default class WithPopoverMenu extends React.PureComponent<   WithPopoverMenuProps,   WithPopoverMenuState > {   container: ShouldFocusContainer;    static defaultProps = {     children: null,     disableClick: false,     onChangeFocus: null,     menuItems: [],     isFocused: false,     shouldFocus: (event: any, container: ShouldFocusContainer) =>       container?.contains(event.target) ||       event.target.id === 'menu-item' ||       event.target.parentNode?.id === 'menu-item',     style: null,   };    constructor(props: WithPopoverMenuProps) {     super(props);     this.state = {       isFocused: props.isFocused!,     };     this.setRef = this.setRef.bind(this);     this.handleClick = this.handleClick.bind(this);   }    UNSAFE_componentWillReceiveProps(nextProps: WithPopoverMenuProps) {     if (nextProps.editMode && nextProps.isFocused && !this.state.isFocused) {       document.addEventListener('click', this.handleClick);       document.addEventListener('drag', this.handleClick);       this.setState({ isFocused: true });     } else if (this.state.isFocused && !nextProps.editMode) {       document.removeEventListener('click', this.handleClick);       document.removeEventListener('drag', this.handleClick);       this.setState({ isFocused: false });     }   }    componentWillUnmount() {     document.removeEventListener('click', this.handleClick);     document.removeEventListener('drag', this.handleClick);   }    setRef(ref: ShouldFocusContainer) {     this.container = ref;   }    handleClick(event: any) {     if (!this.props.editMode) {       return;     }     const {       onChangeFocus,       shouldFocus: shouldFocusFunc,       disableClick,     } = this.props;      const shouldFocus = shouldFocusFunc(event, this.container);      if (!disableClick && shouldFocus && !this.state.isFocused) {       // if not focused, set focus and add a window event listener to capture outside clicks       // this enables us to not set a click listener for ever item on a dashboard       document.addEventListener('click', this.handleClick);       document.addEventListener('drag', this.handleClick);       this.setState(() => ({ isFocused: true }));       if (onChangeFocus) {         onChangeFocus(true);       }     } else if (!shouldFocus && this.state.isFocused) {       document.removeEventListener('click', this.handleClick);       document.removeEventListener('drag', this.handleClick);       this.setState(() => ({ isFocused: false }));       if (onChangeFocus) {         onChangeFocus(false);       }     }   }    render() {     const { children, menuItems, editMode, style } = this.props;     const { isFocused } = this.state;      return (       <WithPopoverMenuStyles         ref={this.setRef}         onClick={this.handleClick}         role=""none""         className={cx(           'with-popover-menu',           editMode && isFocused && 'with-popover-menu--focused',         )}         style={style}       >         {children}         {editMode && isFocused && (menuItems?.length ?? 0) > 0 && (           <PopoverMenuStyles>             {menuItems.map((node: React.ReactNode, i: Number) => (               <div className=""menu-item"" key={`menu-item-${i}`}>                 {node}               </div>             ))}           </PopoverMenuStyles>         )}       </WithPopoverMenuStyles>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_41_248.js
as_42_274,Inefficient Rendering,"const FilterTitlePane: React.FC<Props> = ({   getFilterTitle,   onChange,   onAdd,   onRemove,   onRearrange,   restoreFilter,   currentFilterId,   filters,   removedFilters,   erroredFilters, }) => {   const filtersContainerRef = useRef<HTMLDivElement>(null);   const theme = useTheme();    const handleOnAdd = (type: NativeFilterType) => {     onAdd(type);     setTimeout(() => {       const element = document.getElementById('native-filters-tabs');       if (element) {         const navList = element.getElementsByClassName('ant-tabs-nav-list')[0];         navList.scrollTop = navList.scrollHeight;       }        filtersContainerRef?.current?.scroll?.({         top: filtersContainerRef.current.scrollHeight,         behavior: 'smooth',       });     }, 0);   };   const menu = (     <Menu mode=""horizontal"">       {options.map(item => (         <Menu.Item onClick={() => handleOnAdd(item.type)}>           {item.label}         </Menu.Item>       ))}     </Menu>   );   return (     <TabsContainer>       <AntdDropdown         overlay={menu}         arrow         placement=""topLeft""         trigger={['hover']}       >         <StyledAddBox>           <div data-test=""new-dropdown-icon"" className=""fa fa-plus"" />{' '}           <span>{t('Add filters and dividers')}</span>         </StyledAddBox>       </AntdDropdown>       <div         css={{           height: '100%',           overflowY: 'auto',           marginLeft: theme.gridUnit * 3,         }}       >         <FilterTitleContainer           ref={filtersContainerRef}           filters={filters}           currentFilterId={currentFilterId}           removedFilters={removedFilters}           getFilterTitle={getFilterTitle}           erroredFilters={erroredFilters}           onChange={onChange}           onRemove={onRemove}           onRearrange={onRearrange}           restoreFilter={restoreFilter}         />       </div>     </TabsContainer>   ); };",C:\Users\Owner\Desktop\DatasetFiles\as_42_274.js
as_43_277,Props in initial state,"class RefreshIntervalModal extends React.PureComponent<   RefreshIntervalModalProps,   RefreshIntervalModalState > {   static defaultProps = {     refreshLimit: 0,     refreshWarning: null,   };    modalRef: ModalTriggerRef | null;    constructor(props: RefreshIntervalModalProps) {     super(props);     this.modalRef = React.createRef() as ModalTriggerRef;     this.state = {       refreshFrequency: props.refreshFrequency,     };     this.handleFrequencyChange = this.handleFrequencyChange.bind(this);     this.onSave = this.onSave.bind(this);     this.onCancel = this.onCancel.bind(this);   }    onSave() {     this.props.onChange(this.state.refreshFrequency, this.props.editMode);     this.modalRef?.current?.close();     this.props.addSuccessToast(t('Refresh interval saved'));   }    onCancel() {     this.setState({       refreshFrequency: this.props.refreshFrequency,     });     this.modalRef?.current?.close();   }    handleFrequencyChange(value: number) {     const { refreshIntervalOptions } = this.props;     this.setState({       refreshFrequency: value || refreshIntervalOptions[0][0],     });   }    render() {     const {       refreshLimit = 0,       refreshWarning,       editMode,       refreshIntervalOptions,     } = this.props;     const { refreshFrequency = 0 } = this.state;     const showRefreshWarning =       !!refreshFrequency && !!refreshWarning && refreshFrequency < refreshLimit;      return (       <StyledModalTrigger         ref={this.modalRef}         triggerNode={this.props.triggerNode}         modalTitle={t('Refresh interval')}         modalBody={           <div>             <FormLabel>{t('Refresh frequency')}</FormLabel>             <Select               ariaLabel={t('Refresh interval')}               options={refreshIntervalOptions.map(option => ({                 value: option[0],                 label: t(option[1]),               }))}               value={refreshFrequency}               onChange={this.handleFrequencyChange}               sortComparator={propertyComparator('value')}             />             {showRefreshWarning && (               <RefreshWarningContainer>                 <Alert                   type=""warning""                   message={                     <>                       <div>{refreshWarning}</div>                       <br />                       <strong>{t('Are you sure you want to proceed?')}</strong>                     </>                   }                 />               </RefreshWarningContainer>             )}           </div>         }         modalFooter={           <>             <Button               buttonStyle=""primary""               buttonSize=""small""               onClick={this.onSave}             >               {editMode ? t('Save') : t('Save for this session')}             </Button>             <Button onClick={this.onCancel} buttonSize=""small"">               {t('Cancel')}             </Button>           </>         }       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_43_277.js
as_44_282,Inefficient Rendering,"class SaveModal extends React.PureComponent<SaveModalProps, SaveModalState> {   static defaultProps = defaultProps;    modal: ModalTriggerRef | null;    onSave: (     data: Record<string, any>,     dashboardId: number | string,     saveType: SaveType,   ) => Promise<JsonResponse>;    constructor(props: SaveModalProps) {     super(props);     this.state = {       saveType: props.saveType,       newDashName: props.dashboardTitle + t('[copy]'),       duplicateSlices: false,     };      this.handleSaveTypeChange = this.handleSaveTypeChange.bind(this);     this.handleNameChange = this.handleNameChange.bind(this);     this.saveDashboard = this.saveDashboard.bind(this);     this.toggleDuplicateSlices = this.toggleDuplicateSlices.bind(this);     this.onSave = this.props.onSave.bind(this);     this.modal = React.createRef() as ModalTriggerRef;   }    toggleDuplicateSlices(): void {     this.setState(prevState => ({       duplicateSlices: !prevState.duplicateSlices,     }));   }    handleSaveTypeChange(event: RadioChangeEvent) {     this.setState({       saveType: (event.target as HTMLInputElement).value as SaveType,     });   }    handleNameChange(name: string) {     this.setState({       newDashName: name,       saveType: SAVE_TYPE_NEWDASHBOARD,     });   }    saveDashboard() {     const { saveType, newDashName } = this.state;     const {       dashboardTitle,       dashboardInfo,       layout: positions,       customCss,       dashboardId,       refreshFrequency: currentRefreshFrequency,       shouldPersistRefreshFrequency,       lastModifiedTime,     } = this.props;      // check refresh frequency is for current session or persist     const refreshFrequency = shouldPersistRefreshFrequency       ? currentRefreshFrequency       : dashboardInfo.metadata?.refresh_frequency; // eslint-disable camelcase      const data = {       certified_by: dashboardInfo.certified_by,       certification_details: dashboardInfo.certification_details,       css: customCss,       dashboard_title:         saveType === SAVE_TYPE_NEWDASHBOARD ? newDashName : dashboardTitle,       duplicate_slices: this.state.duplicateSlices,       last_modified_time: lastModifiedTime,       owners: dashboardInfo.owners,       roles: dashboardInfo.roles,       metadata: {         ...dashboardInfo?.metadata,         positions,         refresh_frequency: refreshFrequency,       },     };      if (saveType === SAVE_TYPE_NEWDASHBOARD && !newDashName) {       this.props.addDangerToast(         t('You must pick a name for the new dashboard'),       );     } else {       this.onSave(data, dashboardId, saveType).then((resp: JsonResponse) => {         if (saveType === SAVE_TYPE_NEWDASHBOARD && resp.json?.result?.id) {           window.location.href = `/superset/dashboard/${resp.json.result.id}/`;         }       });       this.modal?.current?.close?.();     }   }    render() {     return (       <ModalTrigger         ref={this.modal}         triggerNode={this.props.triggerNode}         modalTitle={t('Save dashboard')}         modalBody={           <div>             <Radio               value={SAVE_TYPE_OVERWRITE}               onChange={this.handleSaveTypeChange}               checked={this.state.saveType === SAVE_TYPE_OVERWRITE}               disabled={!this.props.canOverwrite}             >               {t('Overwrite Dashboard [%s]', this.props.dashboardTitle)}             </Radio>             <hr />             <Radio               value={SAVE_TYPE_NEWDASHBOARD}               onChange={this.handleSaveTypeChange}               checked={this.state.saveType === SAVE_TYPE_NEWDASHBOARD}             >               {t('Save as:')}             </Radio>             <Input               type=""text""               placeholder={t('[dashboard name]')}               value={this.state.newDashName}               onFocus={e => this.handleNameChange(e.target.value)}               onChange={e => this.handleNameChange(e.target.value)}             />             <div className=""m-l-25 m-t-5"">               <Checkbox                 checked={this.state.duplicateSlices}                 onChange={() => this.toggleDuplicateSlices()}               />               <span className=""m-l-5"">{t('also copy (duplicate) charts')}</span>             </div>           </div>         }         modalFooter={           <div>             <Button               data-test=""modal-save-dashboard-button""               buttonStyle=""primary""               onClick={this.saveDashboard}             >               {t('Save')}             </Button>           </div>         }       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_44_282.js
as_45_283,Props in initial state,"class SaveModal extends React.PureComponent<SaveModalProps, SaveModalState> {   static defaultProps = defaultProps;    modal: ModalTriggerRef | null;    onSave: (     data: Record<string, any>,     dashboardId: number | string,     saveType: SaveType,   ) => Promise<JsonResponse>;    constructor(props: SaveModalProps) {     super(props);     this.state = {       saveType: props.saveType,       newDashName: props.dashboardTitle + t('[copy]'),       duplicateSlices: false,     };      this.handleSaveTypeChange = this.handleSaveTypeChange.bind(this);     this.handleNameChange = this.handleNameChange.bind(this);     this.saveDashboard = this.saveDashboard.bind(this);     this.toggleDuplicateSlices = this.toggleDuplicateSlices.bind(this);     this.onSave = this.props.onSave.bind(this);     this.modal = React.createRef() as ModalTriggerRef;   }    toggleDuplicateSlices(): void {     this.setState(prevState => ({       duplicateSlices: !prevState.duplicateSlices,     }));   }    handleSaveTypeChange(event: RadioChangeEvent) {     this.setState({       saveType: (event.target as HTMLInputElement).value as SaveType,     });   }    handleNameChange(name: string) {     this.setState({       newDashName: name,       saveType: SAVE_TYPE_NEWDASHBOARD,     });   }    saveDashboard() {     const { saveType, newDashName } = this.state;     const {       dashboardTitle,       dashboardInfo,       layout: positions,       customCss,       dashboardId,       refreshFrequency: currentRefreshFrequency,       shouldPersistRefreshFrequency,       lastModifiedTime,     } = this.props;      // check refresh frequency is for current session or persist     const refreshFrequency = shouldPersistRefreshFrequency       ? currentRefreshFrequency       : dashboardInfo.metadata?.refresh_frequency; // eslint-disable camelcase      const data = {       certified_by: dashboardInfo.certified_by,       certification_details: dashboardInfo.certification_details,       css: customCss,       dashboard_title:         saveType === SAVE_TYPE_NEWDASHBOARD ? newDashName : dashboardTitle,       duplicate_slices: this.state.duplicateSlices,       last_modified_time: lastModifiedTime,       owners: dashboardInfo.owners,       roles: dashboardInfo.roles,       metadata: {         ...dashboardInfo?.metadata,         positions,         refresh_frequency: refreshFrequency,       },     };      if (saveType === SAVE_TYPE_NEWDASHBOARD && !newDashName) {       this.props.addDangerToast(         t('You must pick a name for the new dashboard'),       );     } else {       this.onSave(data, dashboardId, saveType).then((resp: JsonResponse) => {         if (saveType === SAVE_TYPE_NEWDASHBOARD && resp.json?.result?.id) {           window.location.href = `/superset/dashboard/${resp.json.result.id}/`;         }       });       this.modal?.current?.close?.();     }   }    render() {     return (       <ModalTrigger         ref={this.modal}         triggerNode={this.props.triggerNode}         modalTitle={t('Save dashboard')}         modalBody={           <div>             <Radio               value={SAVE_TYPE_OVERWRITE}               onChange={this.handleSaveTypeChange}               checked={this.state.saveType === SAVE_TYPE_OVERWRITE}               disabled={!this.props.canOverwrite}             >               {t('Overwrite Dashboard [%s]', this.props.dashboardTitle)}             </Radio>             <hr />             <Radio               value={SAVE_TYPE_NEWDASHBOARD}               onChange={this.handleSaveTypeChange}               checked={this.state.saveType === SAVE_TYPE_NEWDASHBOARD}             >               {t('Save as:')}             </Radio>             <Input               type=""text""               placeholder={t('[dashboard name]')}               value={this.state.newDashName}               onFocus={e => this.handleNameChange(e.target.value)}               onChange={e => this.handleNameChange(e.target.value)}             />             <div className=""m-l-25 m-t-5"">               <Checkbox                 checked={this.state.duplicateSlices}                 onChange={() => this.toggleDuplicateSlices()}               />               <span className=""m-l-5"">{t('also copy (duplicate) charts')}</span>             </div>           </div>         }         modalFooter={           <div>             <Button               data-test=""modal-save-dashboard-button""               buttonStyle=""primary""               onClick={this.saveDashboard}             >               {t('Save')}             </Button>           </div>         }       />     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_45_283.js
as_46_286,Inefficient Rendering,"class SliceAdder extends React.Component {   static sortByComparator(attr) {     const desc = attr === 'changed_on' ? -1 : 1;      return (a, b) => {       if (a[attr] < b[attr]) {         return -1 * desc;       }       if (a[attr] > b[attr]) {         return 1 * desc;       }       return 0;     };   }    constructor(props) {     super(props);     this.state = {       filteredSlices: [],       searchTerm: '',       sortBy: DEFAULT_SORT_KEY,       selectedSliceIdsSet: new Set(props.selectedSliceIds),       showOnlyMyCharts: getItem(         LocalStorageKeys.dashboard__editor_show_only_my_charts,         true,       ),     };     this.rowRenderer = this.rowRenderer.bind(this);     this.searchUpdated = this.searchUpdated.bind(this);     this.handleSelect = this.handleSelect.bind(this);     this.userIdForFetch = this.userIdForFetch.bind(this);     this.onShowOnlyMyCharts = this.onShowOnlyMyCharts.bind(this);   }    userIdForFetch() {     return this.state.showOnlyMyCharts ? this.props.userId : undefined;   }    componentDidMount() {     this.slicesRequest = this.props.fetchSlices(this.userIdForFetch());   }    UNSAFE_componentWillReceiveProps(nextProps) {     const nextState = {};     if (nextProps.lastUpdated !== this.props.lastUpdated) {       nextState.filteredSlices = this.getFilteredSortedSlices(         nextProps.slices,         this.state.searchTerm,         this.state.sortBy,         this.state.showOnlyMyCharts,       );     }      if (nextProps.selectedSliceIds !== this.props.selectedSliceIds) {       nextState.selectedSliceIdsSet = new Set(nextProps.selectedSliceIds);     }      if (Object.keys(nextState).length) {       this.setState(nextState);     }   }    componentWillUnmount() {     // Clears the redux store keeping only selected items     const selectedSlices = pickBy(this.props.slices, value =>       this.state.selectedSliceIdsSet.has(value.slice_id),     );     this.props.updateSlices(selectedSlices);     if (this.slicesRequest && this.slicesRequest.abort) {       this.slicesRequest.abort();     }   }    getFilteredSortedSlices(slices, searchTerm, sortBy, showOnlyMyCharts) {     return Object.values(slices)       .filter(slice =>         showOnlyMyCharts           ? (slice.owners &&               slice.owners.find(owner => owner.id === this.props.userId)) ||             (slice.created_by && slice.created_by.id === this.props.userId)           : true,       )       .filter(createFilter(searchTerm, KEYS_TO_FILTERS))       .sort(SliceAdder.sortByComparator(sortBy));   }    handleChange = debounce(value => {     this.searchUpdated(value);     this.slicesRequest = this.props.fetchSlices(       this.userIdForFetch(),       value,       this.state.sortBy,     );   }, 300);    searchUpdated(searchTerm) {     this.setState(prevState => ({       searchTerm,       filteredSlices: this.getFilteredSortedSlices(         this.props.slices,         searchTerm,         prevState.sortBy,         prevState.showOnlyMyCharts,       ),     }));   }    handleSelect(sortBy) {     this.setState(prevState => ({       sortBy,       filteredSlices: this.getFilteredSortedSlices(         this.props.slices,         prevState.searchTerm,         sortBy,         prevState.showOnlyMyCharts,       ),     }));     this.slicesRequest = this.props.fetchSlices(       this.userIdForFetch(),       this.state.searchTerm,       sortBy,     );   }    rowRenderer({ key, index, style }) {     const { filteredSlices, selectedSliceIdsSet } = this.state;     const cellData = filteredSlices[index];     const isSelected = selectedSliceIdsSet.has(cellData.slice_id);     const type = CHART_TYPE;     const id = NEW_CHART_ID;      const meta = {       chartId: cellData.slice_id,       sliceName: cellData.slice_name,     };     return (       <DragDroppable         key={key}         component={{ type, id, meta }}         parentComponent={{           id: NEW_COMPONENTS_SOURCE_ID,           type: NEW_COMPONENT_SOURCE_TYPE,         }}         index={index}         depth={0}         disableDragDrop={isSelected}         editMode={this.props.editMode}         // we must use a custom drag preview within the List because         // it does not seem to work within a fixed-position container         useEmptyDragPreview         // List library expect style props here         // actual style should be applied to nested AddSliceCard component         style={{}}       >         {({ dragSourceRef }) => (           <AddSliceCard             innerRef={dragSourceRef}             style={style}             sliceName={cellData.slice_name}             lastModified={cellData.changed_on_humanized}             visType={cellData.viz_type}             datasourceUrl={cellData.datasource_url}             datasourceName={cellData.datasource_name}             thumbnailUrl={cellData.thumbnail_url}             isSelected={isSelected}           />         )}       </DragDroppable>     );   }    onShowOnlyMyCharts(showOnlyMyCharts) {     if (!showOnlyMyCharts) {       this.slicesRequest = this.props.fetchSlices(         undefined,         this.state.searchTerm,         this.state.sortBy,       );     }     this.setState(prevState => ({       showOnlyMyCharts,       filteredSlices: this.getFilteredSortedSlices(         this.props.slices,         prevState.searchTerm,         prevState.sortBy,         showOnlyMyCharts,       ),     }));     setItem(       LocalStorageKeys.dashboard__editor_show_only_my_charts,       showOnlyMyCharts,     );   }    render() {     return (       <div         css={css`           height: 100%;           display: flex;           flex-direction: column;         `}       >         <NewChartButtonContainer>           <NewChartButton             buttonStyle=""link""             buttonSize=""xsmall""             onClick={() =>               window.open(                 `/chart/add?dashboard_id=${this.props.dashboardId}`,                 '_blank',                 'noopener noreferrer',               )             }           >             <Icons.PlusSmall />             {t('Create new chart')}           </NewChartButton>         </NewChartButtonContainer>         <Controls>           <Input             placeholder={               this.state.showOnlyMyCharts                 ? t('Filter your charts')                 : t('Filter charts')             }             className=""search-input""             onChange={ev => this.handleChange(ev.target.value)}             data-test=""dashboard-charts-filter-search-input""           />           <StyledSelect             id=""slice-adder-sortby""             value={this.state.sortBy}             onChange={this.handleSelect}             options={Object.entries(KEYS_TO_SORT).map(([key, label]) => ({               label: t('Sort by %s', label),               value: key,             }))}             placeholder={t('Sort by')}           />         </Controls>         <div           css={theme => css`             display: flex;             flex-direction: row;             justify-content: flex-start;             align-items: center;             gap: ${theme.gridUnit}px;             padding: 0 ${theme.gridUnit * 3}px ${theme.gridUnit * 4}px               ${theme.gridUnit * 3}px;           `}         >           <Checkbox             onChange={this.onShowOnlyMyCharts}             checked={this.state.showOnlyMyCharts}           />           {t('Show only my charts')}           <InfoTooltipWithTrigger             placement=""top""             tooltip={t(               `You can choose to display all charts that you have access to or only the ones you own.               Your filter selection will be saved and remain active until you choose to change it.`,             )}           />         </div>         {this.props.isLoading && <Loading />}         {!this.props.isLoading && this.state.filteredSlices.length > 0 && (           <ChartList>             <AutoSizer>               {({ height, width }) => (                 <List                   width={width}                   height={height}                   itemCount={this.state.filteredSlices.length}                   itemSize={DEFAULT_CELL_HEIGHT}                   searchTerm={this.state.searchTerm}                   sortBy={this.state.sortBy}                   selectedSliceIds={this.props.selectedSliceIds}                 >                   {this.rowRenderer}                 </List>               )}             </AutoSizer>           </ChartList>         )}         {this.props.errorMessage && (           <div             css={css`               padding: 16px;             `}           >             {this.props.errorMessage}           </div>         )}         {/* Drag preview is just a single fixed-position element */}         <AddSliceDragPreview slices={this.state.filteredSlices} />       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_46_286.js
as_47_301,Inefficient Rendering,"class AnnotationLayer extends React.PureComponent {   constructor(props) {     super(props);     const {       name,       annotationType,       sourceType,       color,       opacity,       style,       width,       showMarkers,       hideLine,       value,       overrides,       show,       showLabel,       titleColumn,       descriptionColumns,       timeColumn,       intervalEndColumn,       vizType,     } = props;      // Only allow override whole time_range     if ('since' in overrides || 'until' in overrides) {       overrides.time_range = null;       delete overrides.since;       delete overrides.until;     }      // Check if annotationType is supported by this chart     const metadata = getChartMetadataRegistry().get(vizType);     const supportedAnnotationTypes = metadata?.supportedAnnotationTypes || [];     const validAnnotationType = supportedAnnotationTypes.includes(       annotationType,     )       ? annotationType       : supportedAnnotationTypes[0];      this.state = {       // base       name,       annotationType: validAnnotationType,       sourceType,       value,       overrides,       show,       showLabel,       // slice       titleColumn,       descriptionColumns,       timeColumn,       intervalEndColumn,       // display       color: color || AUTOMATIC_COLOR,       opacity,       style,       width,       showMarkers,       hideLine,       // refData       isNew: !name,       isLoadingOptions: true,       valueOptions: [],     };     this.submitAnnotation = this.submitAnnotation.bind(this);     this.deleteAnnotation = this.deleteAnnotation.bind(this);     this.applyAnnotation = this.applyAnnotation.bind(this);     this.fetchOptions = this.fetchOptions.bind(this);     this.handleAnnotationType = this.handleAnnotationType.bind(this);     this.handleAnnotationSourceType =       this.handleAnnotationSourceType.bind(this);     this.handleValue = this.handleValue.bind(this);     this.isValidForm = this.isValidForm.bind(this);   }    componentDidMount() {     const { annotationType, sourceType, isLoadingOptions } = this.state;     this.fetchOptions(annotationType, sourceType, isLoadingOptions);   }    componentDidUpdate(prevProps, prevState) {     if (prevState.sourceType !== this.state.sourceType) {       this.fetchOptions(this.state.annotationType, this.state.sourceType, true);     }   }    getSupportedSourceTypes(annotationType) {     // Get vis types that can be source.     const sources = getChartMetadataRegistry()       .entries()       .filter(({ value: chartMetadata }) =>         chartMetadata.canBeAnnotationType(annotationType),       )       .map(({ key, value: chartMetadata }) => ({         value: key,         label: chartMetadata.name,       }));     // Prepend native source if applicable     if (ANNOTATION_TYPES_METADATA[annotationType]?.supportNativeSource) {       sources.unshift(ANNOTATION_SOURCE_TYPES_METADATA.NATIVE);     }     return sources;   }    isValidFormulaAnnotation(expression, annotationType) {     if (annotationType === ANNOTATION_TYPES.FORMULA) {       return isValidExpression(expression);     }     return true;   }    isValidForm() {     const {       name,       annotationType,       sourceType,       value,       timeColumn,       intervalEndColumn,     } = this.state;     const errors = [       validateNonEmpty(name),       validateNonEmpty(annotationType),       validateNonEmpty(value),     ];     if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE) {       if (annotationType === ANNOTATION_TYPES.EVENT) {         errors.push(validateNonEmpty(timeColumn));       }       if (annotationType === ANNOTATION_TYPES.INTERVAL) {         errors.push(validateNonEmpty(timeColumn));         errors.push(validateNonEmpty(intervalEndColumn));       }     }     errors.push(!this.isValidFormulaAnnotation(value, annotationType));     return !errors.filter(x => x).length;   }    handleAnnotationType(annotationType) {     this.setState({       annotationType,       sourceType: null,       value: null,     });   }    handleAnnotationSourceType(sourceType) {     const { sourceType: prevSourceType } = this.state;      if (prevSourceType !== sourceType) {       this.setState({ sourceType, value: null, isLoadingOptions: true });     }   }    handleValue(value) {     this.setState({       value,       descriptionColumns: [],       intervalEndColumn: null,       timeColumn: null,       titleColumn: null,       overrides: { time_range: null },     });   }    fetchOptions(annotationType, sourceType, isLoadingOptions) {     if (isLoadingOptions) {       if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {         const queryParams = rison.encode({           page: 0,           page_size: FILTER_OPTIONS_LIMIT,         });         SupersetClient.get({           endpoint: `/api/v1/annotation_layer/?q=${queryParams}`,         }).then(({ json }) => {           const layers = json             ? json.result.map(layer => ({                 value: layer.id,                 label: layer.name,               }))             : [];           this.setState({             isLoadingOptions: false,             valueOptions: layers,           });         });       } else if (requiresQuery(sourceType)) {         const queryParams = rison.encode({           filters: [             {               col: 'id',               opr: 'chart_owned_created_favored_by_me',               value: true,             },           ],           order_column: 'slice_name',           order_direction: 'asc',           page: 0,           page_size: FILTER_OPTIONS_LIMIT,         });         SupersetClient.get({           endpoint: `/api/v1/chart/?q=${queryParams}`,         }).then(({ json }) => {           const registry = getChartMetadataRegistry();           this.setState({             isLoadingOptions: false,             valueOptions: json.result               .filter(x => {                 const metadata = registry.get(x.viz_type);                 return metadata && metadata.canBeAnnotationType(annotationType);               })               .map(x => ({                 value: x.id,                 label: x.slice_name,                 slice: {                   ...x,                   data: {                     ...x.form_data,                     groupby: x.form_data.groupby?.map(column =>                       getColumnLabel(column),                     ),                   },                 },               })),           });         });       } else {         this.setState({           isLoadingOptions: false,           valueOptions: [],         });       }     }   }    deleteAnnotation() {     this.props.removeAnnotationLayer();     this.props.close();   }    applyAnnotation() {     if (this.isValidForm()) {       const annotationFields = [         'name',         'annotationType',         'sourceType',         'color',         'opacity',         'style',         'width',         'showMarkers',         'hideLine',         'value',         'overrides',         'show',         'showLabel',         'titleColumn',         'descriptionColumns',         'timeColumn',         'intervalEndColumn',       ];       const newAnnotation = {};       annotationFields.forEach(field => {         if (this.state[field] !== null) {           newAnnotation[field] = this.state[field];         }       });        if (newAnnotation.color === AUTOMATIC_COLOR) {         newAnnotation.color = null;       }        this.props.addAnnotationLayer(newAnnotation);       this.setState({ isNew: false });     }   }    submitAnnotation() {     this.applyAnnotation();     this.props.close();   }    renderOption(option) {     return (       <span         css={{           overflow: 'hidden',           textOverflow: 'ellipsis',           whiteSpace: 'nowrap',         }}         title={option.label}       >         {option.label}       </span>     );   }    renderValueConfiguration() {     const {       annotationType,       sourceType,       value,       valueOptions,       isLoadingOptions,     } = this.state;     let label = '';     let description = '';     if (requiresQuery(sourceType)) {       if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {         label = t('Annotation layer');         description = t('Select the Annotation Layer you would like to use.');       } else {         label = t('Chart');         description = t(           `Use another existing chart as a source for annotations and overlays.           Your chart must be one of these visualization types: [%s]`,           this.getSupportedSourceTypes(annotationType)             .map(x => x.label)             .join(', '),         );       }     } else if (annotationType === ANNOTATION_TYPES.FORMULA) {       label = t('Formula');       description = t(`Expects a formula with depending time parameter 'x'         in milliseconds since epoch. mathjs is used to evaluate the formulas.         Example: '2x+5'`);     }     if (requiresQuery(sourceType)) {       return (         <SelectControl           ariaLabel={t('Annotation layer value')}           name=""annotation-layer-value""           showHeader           hovered           description={description}           label={label}           placeholder=""""           options={valueOptions}           isLoading={isLoadingOptions}           value={value}           onChange={this.handleValue}           validationErrors={!value ? ['Mandatory'] : []}           optionRenderer={this.renderOption}           notFoundContent={<NotFoundContent />}         />       );     }     if (annotationType === ANNOTATION_TYPES.FORMULA) {       return (         <TextControl           name=""annotation-layer-value""           hovered           showHeader           description={description}           label={label}           placeholder=""""           value={value}           onChange={this.handleValue}           validationErrors={             !this.isValidFormulaAnnotation(value, annotationType)               ? [t('Bad formula.')]               : []           }         />       );     }     return '';   }    renderSliceConfiguration() {     const {       annotationType,       sourceType,       value,       valueOptions,       overrides,       titleColumn,       timeColumn,       intervalEndColumn,       descriptionColumns,     } = this.state;     const { slice } = valueOptions.find(x => x.value === value) || {};     if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE && slice) {       const columns = (slice.data.groupby || [])         .concat(slice.data.all_columns || [])         .map(x => ({ value: x, label: x }));       const timeColumnOptions = slice.data.include_time         ? [{ value: '__timestamp', label: '__timestamp' }].concat(columns)         : columns;       return (         <div style={{ marginRight: '2rem' }}>           <PopoverSection             isSelected             title={t('Annotation Slice Configuration')}             info={t(`This section allows you to configure how to use the slice               to generate annotations.`)}           >             {(annotationType === ANNOTATION_TYPES.EVENT ||               annotationType === ANNOTATION_TYPES.INTERVAL) && (               <SelectControl                 ariaLabel={t('Annotation layer time column')}                 hovered                 name=""annotation-layer-time-column""                 label={                   annotationType === ANNOTATION_TYPES.INTERVAL                     ? t('Interval start column')                     : t('Event time column')                 }                 description={t(                   'This column must contain date/time information.',                 )}                 validationErrors={!timeColumn ? ['Mandatory'] : []}                 clearable={false}                 options={timeColumnOptions}                 value={timeColumn}                 onChange={v => this.setState({ timeColumn: v })}               />             )}             {annotationType === ANNOTATION_TYPES.INTERVAL && (               <SelectControl                 ariaLabel={t('Annotation layer interval end')}                 hovered                 name=""annotation-layer-intervalEnd""                 label={t('Interval End column')}                 description={t(                   'This column must contain date/time information.',                 )}                 validationErrors={!intervalEndColumn ? ['Mandatory'] : []}                 options={columns}                 value={intervalEndColumn}                 onChange={value => this.setState({ intervalEndColumn: value })}               />             )}             <SelectControl               ariaLabel={t('Annotation layer title column')}               hovered               name=""annotation-layer-title""               label={t('Title Column')}               description={t('Pick a title for you annotation.')}               options={[{ value: '', label: t('None') }].concat(columns)}               value={titleColumn}               onChange={value => this.setState({ titleColumn: value })}             />             {annotationType !== ANNOTATION_TYPES.TIME_SERIES && (               <SelectControl                 ariaLabel={t('Annotation layer description columns')}                 hovered                 name=""annotation-layer-title""                 label={t('Description Columns')}                 description={t(                   ""Pick one or more columns that should be shown in the annotation. If you don't select a column all of them will be shown."",                 )}                 multi                 options={columns}                 value={descriptionColumns}                 onChange={value => this.setState({ descriptionColumns: value })}               />             )}             <div style={{ marginTop: '1rem' }}>               <CheckboxControl                 hovered                 name=""annotation-override-time_range""                 label={t('Override time range')}                 description={t(`This controls whether the ""time_range"" field from the current                   view should be passed down to the chart containing the annotation data.`)}                 value={'time_range' in overrides}                 onChange={v => {                   delete overrides.time_range;                   if (v) {                     this.setState({                       overrides: { ...overrides, time_range: null },                     });                   } else {                     this.setState({ overrides: { ...overrides } });                   }                 }}               />               <CheckboxControl                 hovered                 name=""annotation-override-timegrain""                 label={t('Override time grain')}                 description={t(`This controls whether the time grain field from the current                   view should be passed down to the chart containing the annotation data.`)}                 value={'time_grain_sqla' in overrides}                 onChange={v => {                   delete overrides.time_grain_sqla;                   delete overrides.granularity;                   if (v) {                     this.setState({                       overrides: {                         ...overrides,                         time_grain_sqla: null,                         granularity: null,                       },                     });                   } else {                     this.setState({ overrides: { ...overrides } });                   }                 }}               />               <TextControl                 hovered                 name=""annotation-layer-timeshift""                 label={t('Time Shift')}                 description={t(`Time delta in natural language                   (example:  24 hours, 7 days, 56 weeks, 365 days)`)}                 placeholder=""""                 value={overrides.time_shift}                 onChange={v =>                   this.setState({ overrides: { ...overrides, time_shift: v } })                 }               />             </div>           </PopoverSection>         </div>       );     }     return '';   }    renderDisplayConfiguration() {     const {       color,       opacity,       style,       width,       showMarkers,       hideLine,       annotationType,     } = this.state;     const colorScheme = getCategoricalSchemeRegistry()       .get(this.props.colorScheme)       .colors.concat();     if (       color &&       color !== AUTOMATIC_COLOR &&       !colorScheme.find(x => x.toLowerCase() === color.toLowerCase())     ) {       colorScheme.push(color);     }     return (       <PopoverSection         isSelected         title={t('Display configuration')}         info={t('Configure your how you overlay is displayed here.')}       >         <SelectControl           ariaLabel={t('Annotation layer stroke')}           name=""annotation-layer-stroke""           label={t('Style')}           // see '../../../visualizations/nvd3_vis.css'           options={[             { value: 'solid', label: t('Solid') },             { value: 'dashed', label: t('Dashed') },             { value: 'longDashed', label: t('Long dashed') },             { value: 'dotted', label: t('Dotted') },           ]}           value={style}           clearable={false}           onChange={v => this.setState({ style: v })}         />         <SelectControl           ariaLabel={t('Annotation layer opacity')}           name=""annotation-layer-opacity""           label={t('Opacity')}           // see '../../../visualizations/nvd3_vis.css'           options={[             { value: '', label: t('Solid') },             { value: 'opacityLow', label: '0.2' },             { value: 'opacityMedium', label: '0.5' },             { value: 'opacityHigh', label: '0.8' },           ]}           value={opacity}           onChange={value => this.setState({ opacity: value })}         />         <div>           <ControlHeader label={t('Color')} />           <div style={{ display: 'flex', flexDirection: 'column' }}>             <CompactPicker               color={color}               colors={colorScheme}               onChangeComplete={v => this.setState({ color: v.hex })}             />             <Button               style={{ marginTop: '0.5rem', marginBottom: '0.5rem' }}               buttonStyle={color === AUTOMATIC_COLOR ? 'success' : 'default'}               buttonSize=""xsmall""               onClick={() => this.setState({ color: AUTOMATIC_COLOR })}             >               {t('Automatic Color')}             </Button>           </div>         </div>         <TextControl           name=""annotation-layer-stroke-width""           label={t('Line width')}           isInt           value={width}           onChange={v => this.setState({ width: v })}         />         {annotationType === ANNOTATION_TYPES.TIME_SERIES && (           <CheckboxControl             hovered             name=""annotation-layer-show-markers""             label={t('Show Markers')}             description={t('Shows or hides markers for the time series')}             value={showMarkers}             onChange={v => this.setState({ showMarkers: v })}           />         )}         {annotationType === ANNOTATION_TYPES.TIME_SERIES && (           <CheckboxControl             hovered             name=""annotation-layer-hide-line""             label={t('Hide Line')}             description={t('Hides the Line for the time series')}             value={hideLine}             onChange={v => this.setState({ hideLine: v })}           />         )}       </PopoverSection>     );   }    render() {     const { isNew, name, annotationType, sourceType, show, showLabel } =       this.state;     const isValid = this.isValidForm();     const metadata = getChartMetadataRegistry().get(this.props.vizType);     const supportedAnnotationTypes = metadata       ? metadata.supportedAnnotationTypes.map(           type => ANNOTATION_TYPES_METADATA[type],         )       : [];     const supportedSourceTypes = this.getSupportedSourceTypes(annotationType);      return (       <>         {this.props.error && (           <span style={{ color: this.props.theme.colors.error.base }}>             ERROR: {this.props.error}           </span>         )}         <div style={{ display: 'flex', flexDirection: 'row' }}>           <div style={{ marginRight: '2rem' }}>             <PopoverSection               isSelected               title={t('Layer configuration')}               info={t('Configure the basics of your Annotation Layer.')}             >               <TextControl                 name=""annotation-layer-name""                 label={t('Name')}                 placeholder=""""                 value={name}                 onChange={v => this.setState({ name: v })}                 validationErrors={!name ? [t('Mandatory')] : []}               />               <CheckboxControl                 name=""annotation-layer-hide""                 label={t('Hide layer')}                 value={!show}                 onChange={v => this.setState({ show: !v })}               />               <CheckboxControl                 name=""annotation-label-show""                 label={t('Show label')}                 value={showLabel}                 hovered                 description={t('Whether to always show the annotation label')}                 onChange={v => this.setState({ showLabel: v })}               />               <SelectControl                 ariaLabel={t('Annotation layer type')}                 hovered                 description={t('Choose the annotation layer type')}                 label={t('Annotation layer type')}                 name=""annotation-layer-type""                 clearable={false}                 options={supportedAnnotationTypes}                 value={annotationType}                 onChange={this.handleAnnotationType}               />               {supportedSourceTypes.length > 0 && (                 <SelectControl                   ariaLabel={t('Annotation source type')}                   hovered                   description={t('Choose the source of your annotations')}                   label={t('Annotation source')}                   name=""annotation-source-type""                   options={supportedSourceTypes}                   notFoundContent={<NotFoundContent />}                   value={sourceType}                   onChange={this.handleAnnotationSourceType}                   validationErrors={!sourceType ? [t('Mandatory')] : []}                 />               )}               {this.renderValueConfiguration()}             </PopoverSection>           </div>           {this.renderSliceConfiguration()}           {this.renderDisplayConfiguration()}         </div>         <div style={{ display: 'flex', justifyContent: 'space-between' }}>           {isNew ? (             <Button buttonSize=""small"" onClick={() => this.props.close()}>               {t('Cancel')}             </Button>           ) : (             <Button buttonSize=""small"" onClick={this.deleteAnnotation}>               {t('Remove')}             </Button>           )}           <div>             <Button               buttonSize=""small""               disabled={!isValid}               onClick={this.applyAnnotation}             >               {t('Apply')}             </Button>              <Button               buttonSize=""small""               buttonStyle=""primary""               disabled={!isValid}               onClick={this.submitAnnotation}             >               {t('OK')}             </Button>           </div>         </div>       </>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_47_301.js
as_48_304,Inefficient Rendering,"class AnnotationLayerControl extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       popoverVisible: {},       addedAnnotationIndex: null,     };     this.addAnnotationLayer = this.addAnnotationLayer.bind(this);     this.removeAnnotationLayer = this.removeAnnotationLayer.bind(this);     this.handleVisibleChange = this.handleVisibleChange.bind(this);   }    componentDidMount() {     // preload the AnnotationLayer component and dependent libraries i.e. mathjs     AnnotationLayer.preload();   }    UNSAFE_componentWillReceiveProps(nextProps) {     const { name, annotationError, validationErrors, value } = nextProps;     if (Object.keys(annotationError).length && !validationErrors.length) {       this.props.actions.setControlValue(         name,         value,         Object.keys(annotationError),       );     }     if (!Object.keys(annotationError).length && validationErrors.length) {       this.props.actions.setControlValue(name, value, []);     }   }    addAnnotationLayer(originalAnnotation, newAnnotation) {     let annotations = this.props.value;     if (annotations.includes(originalAnnotation)) {       annotations = annotations.map(anno =>         anno === originalAnnotation ? newAnnotation : anno,       );     } else {       annotations = [...annotations, newAnnotation];       this.setState({ addedAnnotationIndex: annotations.length - 1 });     }      this.props.refreshAnnotationData({       annotation: newAnnotation,       force: true,     });      this.props.onChange(annotations);   }    handleVisibleChange(visible, popoverKey) {     this.setState(prevState => ({       popoverVisible: { ...prevState.popoverVisible, [popoverKey]: visible },     }));   }    removeAnnotationLayer(annotation) {     const annotations = this.props.value.filter(anno => anno !== annotation);     // So scrollbar doesnt get stuck on hidden     const element = getSectionContainerElement();     if (element) {       element.style.setProperty('overflow-y', 'auto', 'important');     }     this.props.onChange(annotations);   }    renderPopover(popoverKey, annotation, error) {     const id = annotation?.name || '_new';      return (       <div id={`annotation-pop-${id}`} data-test=""popover-content"">         <AnnotationLayer           {...annotation}           error={error}           colorScheme={this.props.colorScheme}           vizType={this.props.vizType}           addAnnotationLayer={newAnnotation =>             this.addAnnotationLayer(annotation, newAnnotation)           }           removeAnnotationLayer={() => this.removeAnnotationLayer(annotation)}           close={() => {             this.handleVisibleChange(false, popoverKey);             this.setState({ addedAnnotationIndex: null });           }}         />       </div>     );   }    renderInfo(anno) {     const { annotationError, annotationQuery, theme } = this.props;     if (annotationQuery[anno.name]) {       return (         <i           className=""fa fa-refresh""           style={{ color: theme.colors.primary.base }}           aria-hidden         />       );     }     if (annotationError[anno.name]) {       return (         <InfoTooltipWithTrigger           label=""validation-errors""           bsStyle=""danger""           tooltip={annotationError[anno.name]}         />       );     }     if (!anno.show) {       return <span style={{ color: theme.colors.error.base }}> Hidden </span>;     }     return '';   }    render() {     const { addedAnnotationIndex } = this.state;     const addedAnnotation = this.props.value[addedAnnotationIndex];      const annotations = this.props.value.map((anno, i) => (       <ControlPopover         key={i}         trigger=""click""         title={t('Edit annotation layer')}         css={theme => ({           '&:hover': {             cursor: 'pointer',             backgroundColor: theme.colors.grayscale.light4,           },         })}         content={this.renderPopover(           i,           anno,           this.props.annotationError[anno.name],         )}         visible={this.state.popoverVisible[i]}         onVisibleChange={visible => this.handleVisibleChange(visible, i)}       >         <CustomListItem selectable>           <span>{anno.name}</span>           <span style={{ float: 'right' }}>{this.renderInfo(anno)}</span>         </CustomListItem>       </ControlPopover>     ));      const addLayerPopoverKey = 'add';     return (       <div>         <List bordered css={theme => ({ borderRadius: theme.gridUnit })}>           {annotations}           <ControlPopover             trigger=""click""             content={this.renderPopover(addLayerPopoverKey, addedAnnotation)}             title={t('Add annotation layer')}             visible={this.state.popoverVisible[addLayerPopoverKey]}             destroyTooltipOnHide             onVisibleChange={visible =>               this.handleVisibleChange(visible, addLayerPopoverKey)             }           >             <CustomListItem selectable>               <i                 data-test=""add-annotation-layer-button""                 className=""fa fa-plus""               />{' '}               &nbsp; {t('Add annotation layer')}             </CustomListItem>           </ControlPopover>         </List>       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_48_304.js
as_49_306,Inefficient Rendering,"class CollectionControl extends React.Component {   constructor(props) {     super(props);     this.onAdd = this.onAdd.bind(this);   }    onChange(i, value) {     const newValue = [...this.props.value];     newValue[i] = { ...this.props.value[i], ...value };     this.props.onChange(newValue);   }    onAdd() {     this.props.onChange(this.props.value.concat([this.props.itemGenerator()]));   }    onSortEnd({ oldIndex, newIndex }) {     this.props.onChange(arrayMove(this.props.value, oldIndex, newIndex));   }    removeItem(i) {     this.props.onChange(this.props.value.filter((o, ix) => i !== ix));   }    renderList() {     if (this.props.value.length === 0) {       return <div className=""text-muted"">{this.props.placeholder}</div>;     }     const Control = controlMap[this.props.controlName];     return (       <SortableList         useDragHandle         lockAxis=""y""         onSortEnd={this.onSortEnd.bind(this)}         bordered         css={theme => ({           borderRadius: theme.gridUnit,         })}       >         {this.props.value.map((o, i) => {           // label relevant only for header, not here           const { label, ...commonProps } = this.props;           return (             <SortableListItem               className=""clearfix""               css={{ justifyContent: 'flex-start' }}               key={this.props.keyAccessor(o)}               index={i}             >               <SortableDragger />               <div                 css={theme => ({                   flex: 1,                   marginLeft: theme.gridUnit * 2,                   marginRight: theme.gridUnit * 2,                 })}               >                 <Control                   {...commonProps}                   {...o}                   onChange={this.onChange.bind(this, i)}                 />               </div>               <InfoTooltipWithTrigger                 icon=""times""                 label=""remove-item""                 tooltip={t('Remove item')}                 bsStyle=""primary""                 onClick={this.removeItem.bind(this, i)}               />             </SortableListItem>           );         })}       </SortableList>     );   }    render() {     const { theme } = this.props;     return (       <div data-test=""CollectionControl"" className=""CollectionControl"">         <HeaderContainer>           <ControlHeader {...this.props} />           <AddIconButton onClick={this.onAdd}>             <Icons.PlusLarge               iconSize=""s""               iconColor={theme.colors.grayscale.light5}             />           </AddIconButton>         </HeaderContainer>         {this.renderList()}       </div>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_49_306.js
as_50_309,Inefficient Rendering,"class DatasourceControl extends React.PureComponent {   constructor(props) {     super(props);     this.state = {       showEditDatasourceModal: false,       showChangeDatasourceModal: false,       showSaveDatasetModal: false,     };   }    onDatasourceSave = datasource => {     this.props.actions.changeDatasource(datasource);     const { temporalColumns, defaultTemporalColumn } =       getTemporalColumns(datasource);     const { columns } = datasource;     // the current granularity_sqla might not be a temporal column anymore     const timeCol = this.props.form_data?.granularity_sqla;     const isGranularitySqalTemporal = columns.find(       ({ column_name }) => column_name === timeCol,     )?.is_dttm;     // the current main_dttm_col might not be a temporal column anymore     const isDefaultTemporal = columns.find(       ({ column_name }) => column_name === defaultTemporalColumn,     )?.is_dttm;      // if the current granularity_sqla is empty or it is not a temporal column anymore     // let's update the control value     if (datasource.type === 'table' && !isGranularitySqalTemporal) {       const temporalColumn = isDefaultTemporal         ? defaultTemporalColumn         : temporalColumns?.[0];       this.props.actions.setControlValue(         'granularity_sqla',         temporalColumn || null,       );     }      if (this.props.onDatasourceSave) {       this.props.onDatasourceSave(datasource);     }   };    toggleShowDatasource = () => {     this.setState(({ showDatasource }) => ({       showDatasource: !showDatasource,     }));   };    toggleChangeDatasourceModal = () => {     this.setState(({ showChangeDatasourceModal }) => ({       showChangeDatasourceModal: !showChangeDatasourceModal,     }));   };    toggleEditDatasourceModal = () => {     this.setState(({ showEditDatasourceModal }) => ({       showEditDatasourceModal: !showEditDatasourceModal,     }));   };    toggleSaveDatasetModal = () => {     this.setState(({ showSaveDatasetModal }) => ({       showSaveDatasetModal: !showSaveDatasetModal,     }));   };    handleMenuItemClick = ({ key }) => {     switch (key) {       case CHANGE_DATASET:         this.toggleChangeDatasourceModal();         break;        case EDIT_DATASET:         this.toggleEditDatasourceModal();         break;        case VIEW_IN_SQL_LAB:         {           const { datasource } = this.props;           const payload = {             datasourceKey: `${datasource.id}__${datasource.type}`,             sql: datasource.sql,           };           SupersetClient.postForm('/superset/sqllab/', {             form_data: safeStringify(payload),           });         }         break;        case SAVE_AS_DATASET:         this.toggleSaveDatasetModal();         break;        default:         break;     }   };    render() {     const {       showChangeDatasourceModal,       showEditDatasourceModal,       showSaveDatasetModal,     } = this.state;     const { datasource, onChange, theme } = this.props;     const isMissingDatasource = !datasource?.id;     let isMissingParams = false;     if (isMissingDatasource) {       const datasourceId = getUrlParam(URL_PARAMS.datasourceId);       const sliceId = getUrlParam(URL_PARAMS.sliceId);        if (!datasourceId && !sliceId) {         isMissingParams = true;       }     }      const { user } = this.props;     const allowEdit =       datasource.owners?.map(o => o.id || o.value).includes(user.userId) ||       isUserAdmin(user);      const canAccessSqlLab = canUserAccessSqlLab(user);      const editText = t('Edit dataset');      const defaultDatasourceMenu = (       <Menu onClick={this.handleMenuItemClick}>         {this.props.isEditable && !isMissingDatasource && (           <Menu.Item             key={EDIT_DATASET}             data-test=""edit-dataset""             disabled={!allowEdit}           >             {!allowEdit ? (               <Tooltip                 title={t(                   'You must be a dataset owner in order to edit. Please reach out to a dataset owner to request modifications or edit access.',                 )}               >                 {editText}               </Tooltip>             ) : (               editText             )}           </Menu.Item>         )}         <Menu.Item key={CHANGE_DATASET}>{t('Swap dataset')}</Menu.Item>         {!isMissingDatasource && canAccessSqlLab && (           <Menu.Item key={VIEW_IN_SQL_LAB}>{t('View in SQL Lab')}</Menu.Item>         )}       </Menu>     );      const queryDatasourceMenu = (       <Menu onClick={this.handleMenuItemClick}>         <Menu.Item key={QUERY_PREVIEW}>           <ModalTrigger             triggerNode={               <span data-test=""view-query-menu-item"">{t('Query preview')}</span>             }             modalTitle={t('Query preview')}             modalBody={               <ViewQuery                 sql={datasource?.sql || datasource?.select_star || ''}               />             }             modalFooter={               <ViewQueryModalFooter                 changeDatasource={this.toggleSaveDatasetModal}                 datasource={datasource}               />             }             draggable={false}             resizable={false}             responsive           />         </Menu.Item>         {canAccessSqlLab && (           <Menu.Item key={VIEW_IN_SQL_LAB}>{t('View in SQL Lab')}</Menu.Item>         )}         <Menu.Item key={SAVE_AS_DATASET}>{t('Save as dataset')}</Menu.Item>       </Menu>     );      const { health_check_message: healthCheckMessage } = datasource;      let extra;     if (datasource?.extra) {       if (isString(datasource.extra)) {         try {           extra = JSON.parse(datasource.extra);         } catch {} // eslint-disable-line no-empty       } else {         extra = datasource.extra; // eslint-disable-line prefer-destructuring       }     }      const titleText = isMissingDatasource       ? t('Missing dataset')       : getDatasourceTitle(datasource);      const tooltip = titleText;      return (       <Styles data-test=""datasource-control"" className=""DatasourceControl"">         <div className=""data-container"">           {datasourceIconLookup[datasource?.type]}           {renderDatasourceTitle(titleText, tooltip)}           {healthCheckMessage && (             <Tooltip title={healthCheckMessage}>               <Icons.AlertSolid iconColor={theme.colors.warning.base} />             </Tooltip>           )}           {extra?.warning_markdown && (             <WarningIconWithTooltip warningMarkdown={extra.warning_markdown} />           )}           <AntdDropdown             overlay={               datasource.type === DatasourceType.Query                 ? queryDatasourceMenu                 : defaultDatasourceMenu             }             trigger={['click']}             data-test=""datasource-menu""           >             <Icons.MoreVert               className=""datasource-modal-trigger""               data-test=""datasource-menu-trigger""             />           </AntdDropdown>         </div>         {/* missing dataset */}         {isMissingDatasource && isMissingParams && (           <div className=""error-alert"">             <ErrorAlert               level=""warning""               title={t('Missing URL parameters')}               source=""explore""               subtitle={                 <>                   <p>                     {t(                       'The URL is missing the dataset_id or slice_id parameters.',                     )}                   </p>                 </>               }             />           </div>         )}         {isMissingDatasource && !isMissingParams && (           <div className=""error-alert"">             <ErrorAlert               level=""warning""               title={t('Missing dataset')}               source=""explore""               subtitle={                 <>                   <p>                     {t(                       'The dataset linked to this chart may have been deleted.',                     )}                   </p>                   <p>                     <Button                       buttonStyle=""primary""                       onClick={() =>                         this.handleMenuItemClick({ key: CHANGE_DATASET })                       }                     >                       {t('Swap dataset')}                     </Button>                   </p>                 </>               }             />           </div>         )}         {showEditDatasourceModal && (           <DatasourceModal             datasource={datasource}             show={showEditDatasourceModal}             onDatasourceSave={this.onDatasourceSave}             onHide={this.toggleEditDatasourceModal}           />         )}         {showChangeDatasourceModal && (           <ChangeDatasourceModal             onDatasourceSave={this.onDatasourceSave}             onHide={this.toggleChangeDatasourceModal}             show={showChangeDatasourceModal}             onChange={onChange}           />         )}         {showSaveDatasetModal && (           <SaveDatasetModal             visible={showSaveDatasetModal}             onHide={this.toggleSaveDatasetModal}             buttonTextOnSave={t('Save')}             buttonTextOnOverwrite={t('Overwrite')}             modalDescription={t(               'Save this query as a virtual dataset to continue exploring',             )}             datasource={getDatasourceAsSaveableDataset(datasource)}             openWindow={false}             formData={this.props.form_data}           />         )}       </Styles>     );   } }",C:\Users\Owner\Desktop\DatasetFiles\as_50_309.js
